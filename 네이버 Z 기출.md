# 네이버Z
<br>

### 네트워크 TCP, UDP 차이?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
[참고: https://base64.guru/]
   
+  
</details>


-----------------------

### HTTP?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
[참고: HTTP 완벽 가이드 p.287]
   
+    
</details>
 
-----------------------

### HTTP vs HTTPS?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
[참고: HTTP 완벽 가이드 p.287]
   
+    
</details>
 
-----------------------

### Restful API란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
[참고: ]
   
+    
</details>

-----------------------

### HTTP 자원은 어떻게 사용되는 것이며 HTTP 메소드는 어떻게 사용되는 것인지?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
[참고: ] 

+ 
   
</details>


-----------------------

### RDB index란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>

+ 
</details>


-----------------------

### 속도를 최대한 높이기 위해 모든 컬럼에 index를 걸어놓는 게 좋을까?

<details>
   <summary> 답안 보기 (👈 Click)</summary>

+ 
</details>


-----------------------


### JPA n+1 문제란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>

+ 
</details>


-----------------------

### JPA n+1 문제 해결 방법은?

<details>
   <summary> 답안 보기 (👈 Click)</summary>

+ 
</details>


-----------------------

### 배열과 리스트의 차이점은?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
[참고: 자바의 정석 p.581]

+ 배열 -
  리스트 - List 인터페이스는 중복을 허용하면서 저장순서가 유지되는 컬렉션을 구현하는데 사용된다.
           List 인터페이스에 정의된 메서드는 다음과 같다.
           Collection 인터페이스로부터 상속받은 것들은 제외하였다.  
   
</details>


-----------------------

### 어레이리스트와 링크드리스트의 차이점은?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
[참고: 자바의 정석 p.584, p.596] 
+ ArrayList - ArrayList는 컬렉션 프레임웍에서 가장 많이 사용되는 컬렉션 클래스일 것이다.
              이 ArrayList는 List인터페이스를 구현하기 때문에 데이터의 저장순서가 유지되고 중복을 허용한다는 특징을 갖는다.
              ArrayList는 기존의 Vector를 개선한 것으로 Vector와 구현원리와 기능적인 측면에서 동일하다고 할 수 있다.
              앞에서 얘기했던 것과 같이 Vector는 기존에 작성된 소스와의 호환성을 위해서 계속 남겨 두고 있을 뿐이기 때문에
              가능하면 Vector보다는 ArrayList를 사용하자.
              ArrayList는 Object배열을 이용해서 데이터를 순차적으로 저장한다.
              예를 들면, 첫 번째로 저장한 객체는 Object 배열의 0번째 위치에 저장되고,
              그 다음에 저장하는 객체는 1번째 위치에 저장된다.
              이런 식으로 계속 배열에 순서대로 저장되며, 배열에 더 이상 저장할 공간이 없으면 보다 큰 새로운 배열을 생성해서
              기존의 배열에 저장된 내용을 새로운 배열에 복사한 다음에 저장된다.             
  LinkedList - 배열은 가장 기본적인 형태의 자료구조로 구조가 간단하며, 사용하기 쉽고 데이터를 읽어 오는데 걸리는 시간(접근 시간, access time)이
               가장 빠르다는 장점을 가지고 있지만 다음과 같은 단점도 가지고 있다.
               1. 크기를 변경할 수 없다
               - 크기를 변경할 수 없으므로 새로운 배열을 생성해서 데이터를 복사해야 한다.
               - 실행속도를 향상시키기 위해서는 충분히 큰 크기의 배열을 생성해야 하므로 메모리가 낭비된다.
               2. 비순차적인 데이터의 추가 또는 삭제에 시간이 많이 걸린다.
               - 차례대로 데이터를 추가하고 마지막에서부터 데이터를 삭제하는 것은 빠르지만,
                 배열의 중간에 데이터를 추가하려면, 빈자리를 만들기 위해 다른 데이터들을 복사해서 이동해야 한다.

               이러한 배열의 단점을 보완하기 위해서 링크드 리스트(linked list)라는 자료구조가 고안되었다.
               배열은 모든 데이터가 연속적으로 존재하지만, 링크드 리스트는 불연속적으로 존재하는 데이터를 서로 연결(link)한 형태로 구성되어 있다.

               위의 그림에서 알 수 있듯이 링크드 리스트의 각 요소(node)들은 자신과 연결된 다음 요소에 대한 참조(주소값)와 데이터로 구성되어 있다.
               링크드 리스트에서의 데이터 삭제는 간단하다. 삭제하고자 하는 요소의 이전요소가 삭제하고자 하는 요소의 다음 요소를 참조하도록 변경하기만 하면 된다.
               단 하나의 참조만 변경하면 삭제가 이루어지는 것이다. 배열처럼 데이터를 이동하기 위해 복사하는 과정이 없기 때문에 처리속도가 매우 빠르다.

               새로운 데이터를 추가할 때는 새로운 요소를 생성한 다음 추가하고자 하는 위치의 이전 요소의 참조를 새로운 요소에 대한 참조로 변경해주고,
               새로운 요소가 그 다음 요소를 참조하도록 변경하기만 하면 되므로 처리속도가 매우 빠르다.

               링크드 리스트는 이동방향이 단방향이기 때문에 다음 요소에 대한 접근은 쉽지만 이전요소에 대한 접근은 어렵다.
               이 점을 보완한 것이 더블 링크드 리스트(이중 연결리스트, doubly linked list)이다.
               더블 링크드 리스트는 단순히 링크드 리스트에 참조변수를 하나 더 추가하여 다음 요소에 대한 참조뿐 아니라
               이전 요소에 대한 참조가 가능하도록 했을 뿐, 그 외에는 링크드 리스트와 같다.
               더블 링크드 리스트는 링크드 리스트보다 각 요소에 대한 접근과 이동이 쉽기 때문에 링크드 리스트보다 더 많이 사용된다.            
</details>


-----------------------

### Set과 Map의 차이점은?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
[참고: 자바의 정석 p.579]
+ Set은 순서를 유지하지 않는 데이터의 집합이며 데이터의 중복을 허용하지 않는다.
  구현 클래스로는 HashSet과 TreeSet이 있다. 
  Map은 키(key)와 값(value)의 쌍(pair)으로 이루어진 데이터의 집합이다. 
  순서는 유지되지 않으며, 키는 중복을 허용하지 않고, 값은 중복을 허용한다.    
</details>


-----------------------

### HashMap과 TreeMap의 차이점은?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
[참고: 자바의 정석 p.644] 
+ HashTable과 HashMap의 관계는 Vector와 ArrayList의 관계와 같아서 HashTable보다는 
</details>


-----------------------

### Set과 Map에서 넣은 데이터의 순서가 보장되는가?

<details>
   <summary> 답안 보기 (👈 Click)</summary>

+ 
</details>


-----------------------

### 인터페이스와 추상클래스의 차이점은?

<details>
   <summary> 답안 보기 (👈 Click)</summary>

+ 
</details>


-----------------------

### 멤버도, 상수도 없고 추상메소드만 있을 때, 인터페이스와 추상클래스의 차이점은?

<details>
   <summary> 답안 보기 (👈 Click)</summary>

+ 
</details>


-----------------------

### 자바의 equals와 hashcode는?

<details>
   <summary> 답안 보기 (👈 Click)</summary>

+ 
</details>


-----------------------

### 자바의 equals와 =의 다른 점은?

<details>
   <summary> 답안 보기 (👈 Click)</summary>

+ 
</details>


-----------------------

### 자바의 박싱과 언박싱이란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
[참고: 자바의 정석 p.494]   
+ JDK 1.5 이전에는 기본형과 참조형 간의 연산이 불가능했기 때문에,
래퍼 클래스로 기본형을 객체로 만들어서 연산해야 했다.

그러나 이제는 기본형과 참조형 간의 덧셈이 가능하다.
자바 언어의 규칙이 바뀐 것은 아니고, 컴파일러가 자동으로 변환하는 코드를 넣어주기 때문이다.
아래의 경우, 컴파일러가 Integer 객체를 int 타입으로 변환해주는 intValue()를 추가해준다.

이 외에도 내부적으로 객체 배열을 가지고 있는 Vector 클래스나 ArrayList 클래스에
기본형 값을 저장해야 할 때나 형변환이 필요할 때도 컴파일러가 자동적으로 코드를 추가해준다.
기본형 값을 래퍼 클래스의 객체로 자동 변환해주는 것을 오토박싱(autoboxing)이라고 하고,
반대로 변환하는 것을 언박싱(unboxing)이라고 한다. 

</details>


-----------------------

### 자바의 Primitive 타입과 Reference 타입이 왜 나눠져 있을까?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
[참고: 자바의 정석 p.28]
+ 기본형에는 모두 8개의 타입(자료형)이 있으며,
크게 논리형, 문자형, 정수형, 실수형으로 구분된다

문자형인 char는 문자를 내부적으로 정수(유니코드)로 저장하기 때문에
정수형과 별반 다르지 않으며, 정수형 또는 실수형과 연산도 가능하다
반면에 boolean은 다른 기본형과의 연산이 불가능하다.
즉, boolean을 제외한 나머지 7개의 기본형은 서로 연산과 변환이 가능하다. 

정수는 가장 많이 사용되므로 타입을 4가지나 제공한다.
각 타입마다 저장할 수 있는 값의 범위가 다르므로
저장할 값의 범위에 맞는 타입을 선택하면 되지만,
일반적으로 int를 많이 사용한다.
왜냐하면 int는 CPU가 가장 효율적으로 처리할 수 있는 타입이기 때문이다.
효율적인 실행보다 메모리를 절약하려면 byte나 short를 선택하자. 

기본 자료형의 종류와 크기는 반드시 외워야 하며, 아래의 문장들이 도움이 될 것이다.

1) boolean은 true와 false 두 가지 값만 표현할 수 있으면 되므로, 가장 작은 크기인 1 byte
2) char은 자바에서 유니코드(2 byte 문자체계)를 사용하므로 2byte
3) byte는 크기가 1 byte라서 byte
4) int(4 byte)를 기준으로 짧아서 short(2 byte), 길어서 long(8 byte), 
5) float는 실수값을 부동소수점 방식으로 저장하기 때문에 float
6) double은 float보다 두 배의 크기(8 byte)를 갖기 때문에 double
 
</details>


-----------------------

### 자바의 접근제어자란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
[참고: 자바의 정석 p.348]
+ 
접근 제어자는 멤버 또는 클래스에 사용되어, 해당하는 멤버 또는 클래스를 외부에서 접근하지 못하도록 제한하는 역할을 한다. 
접근 제어자가 default임을 알리기 위해 실제로 default를 붙이지는 않는다.
클래스나 멤버변수, 메서드, 생성자에 접근 제어자가 지정되어 있지 않다면,
접근 제어자가 default임을 뜻한다.

접근 제어자가 사용될 수 있는 곳 - 클래스, 멤버변수, 메서드, 생성자
private - 같은 클래스 내에서만 접근이 가능하다
default - 같은 패키지 내에서만 접근이 가능하다
protected - 같은 패키지 내에서, 그리고 다른 패키지의 자손 클래스에서 접근이 가능하다
public - 접근 제한이 전혀 없다

접근 범위가 넓은 쪽에서 좁은 쪽의 순으로 왼쪽부터 나열하면 다음과 같다
public > protected > (default) > private

public은 접근 제한이 전혀 없는 것이고, private은 같은 클래스 내에서만 사용하도록 제한하는
가장 높은 제한이다. 그리고 default는 같은 패키지내의 클래스에서만 접근이 가능하도록 
하는 것이다. 
마지막으로 protected는 패키지에 관계없이 상속관계에 있는 것이 제한 목적이지만,
같은 패키지 내에서도 접근이 가능하다.
그래서 protected가 default보다 접근범위가 더 넓다. 

</details>


-----------------------

### 자바의 접근제어자 예약어는 다 그대로 쓰면 되는지? 생략이 가능한지?
<details>
   <summary> 답안 보기 (👈 Click)</summary>
[참고: 자바의 정석 p.348]
+ 접근 제어자가 default임을 알리기 위해 실제로 default를 붙이지는 않는다.
  클래스나 멤버변수, 메서드, 생성자에 접근 제어자가 지정되어 있지 않다면, 
  접근 제어자가 default임을 뜻한다
</details>


-----------------------

### 스레드와 프로세스의 차이점은?
<details>
   <summary> 답안 보기 (👈 Click)</summary>

+ 
</details>


-----------------------


 

 
입코딩으로 "캐시"를 구현해 보세요.

조건: 데이터를 최대 n개까지 저장할 수 있으며. 캐시가 꽉 찼을 경우 LRU 방식으로 기존 데이터 제거 / 새 데이터를 추가할 수 있어야 한다.

코드리뷰를 해본 적 있는지, 또는 오픈소스에 기여해본 적 있는지. 누군가의 코드를 리뷰한다면, 중요하게 생각하는 게 무엇인지

기본적인 내용을 확실히 알고 있는지 확인하려는 목적의 꼬리질문이 매우 많았다. 예컨대 캐시 구현을 위해 해시테이블 자료구조를 언급하고 시간복잡도 O(1)을 언급하면 "Open Addressing 방식에서 테이블 크기를 늘릴 때에는 O(n) 아니냐, 항상 O(1)이 맞는가?" 라던가.

올바른 답변을 할 수 있도록 유도해주기도 했다. 캐시 문제를 풀기 위해서는 해시테이블과 Double linked List 두 개의 자료구조를 활용해야 하는데, Double linked List를 떠올리지 못해서 헤메고 있으니 면접관이 먼저 자료구조를 언급하고, 자료구조의 특징을 설명해보라고 했었다.

코드리뷰 관련해서 '프로그래밍 철학'을 물어본 점이 인상적이었음.

"좋은 코드란 무엇인가"를 고민해봤어야 깊이있는 답변을 할 수 있었겠다

-----------------------

### JDBC란?
<details>
   <summary> 답안 보기 (👈 Click)</summary>
[참고: 토비의 스프링 2권 P.243]

+  
  JDBC는 자바의 데이터 액세스 기술의 기본이 되는 로우레벨의 API다. 
  JDBC는 표준 인터페이스를 제공하고, 각 DB 벤더와 개발팀에서 이 인터페이스를 구현한
드라이버를 제공하는 방식으로 사용된다. 그 덕분에 SQL의 호환성만 유지한다면
JDBC로 개발한 코드는 DB가 변경돼도 그대로 재사용할 수 있다는 장점이 있다. 

JDBC는 모든 자바의 데이터 액세스 기술의 근간이 된다.
엔티티 클래스와 애노테이션을 이용하는 최신 ORM 기술도 내부적으로는 DB와의 연동을 위해
JDBC를 이용한다. 그만큼 안정적이고 유연한 기술이라고 볼 수 있지만, 
반대로 점차 로우레벨 기술로 취급되고 있다는 뜻이기도 하다. 

Vol.1에서 이미 JDBC API를 이용한 개발 방식의 문제점과 한계 등을 살펴봤다.
간단한 SQL을 하나 실행하는 데도 매우 번잡한 코드가 필요하고,
DB에 따라 일관성 없는 정보를 가진 채로 던져지는 체크 예외를 처리해야 하며,
SQL은 코드 내에서 직접 문자로 제공해야 하는 등의 불편을 감수해야 한다.
자칫 커넥션과 같은 공유 리소스를 제대로 릴리스해주지 않으면 
시간이 지나면서 시스템의 자원이 바닥나는 심각한 버그를 심어놓을 수도 있다.
JDBC는 대부분의 개발자가 가장 잘 알고 있는 친숙한 데이터 액세스 기술이다. 
따라서 별도의 학습 없이도 개발이 가능하다는 장점이 있다. 

스프링 JDBC는 이러한 JDBC 개발의 장점과 단순성을 그대로 유지하면서도 기존 JDBC API
사용 방법의 단점을 템플릿/콜백 패턴을 이용해 극복할 수 있게 해주고,
가장 간결한 형태의 API의 사용법을 제공하며,
JDBC API에서는 지원되지 않는 편리한 기능을 제공해주기도 한다. 
물론 그만큼 스프링 JDBC API의 사용 방법과 동작 원리를 익혀야 한다는 부담이 있지만
한 번 익숙해지면 웬만한 최신 데이터 액세스 기술 못지않은 생산성과 안정성을 확보할 수 있고,
동시에 JDBC가 제공하는 모든 기능을 100% 활용할 수도 있다.

JDBC의 예제 코드는 springbook.learningtest.spring.jdbc 패키지에서 찾을 수 있다. 

</details>


-----------------------

### ORM이란?
<details>
   <summary> 답안 보기 (👈 Click)</summary>
[참고: 자바 ORM 표준 프로그래밍 p.54]
+ 
ORM은 이름 그대로 객체와 관계형 데이터베이스를 매핑한다는 뜻이다.
ORM 프레임워크는 객체와 테이블을 매핑해서 패러다임의 불일치 문제를 개발자 대신 해결해준다.
예를 들어, ORM 프레임워크를 사용하면 객체를 데이터베이스에 저장할 때,
INSERT SQL을 직접 작성하는 것이 아니라 객체를 마치 자바 컬렉션에 저장하듯이
ORM 프레임워크에 저장하면 된다.
그러면 ORM 프레임워크가 적절한 INSERT SQL을 생성해서 데이터베이스 객체를 저장해준다.
 
</details>


-----------------------

### 로드밸런싱이란?(L4/ L7)
<details>
   <summary> 답안 보기 (👈 Click)</summary>
[참고: 가상 면접 사례로 배우는 대규모 시스템 설계 기초 p.6]
+  로드밸런서는 부하 분산 집합에 속한 웹 서버들에게 트래픽 부하를 고르게 분산하는 역할을 한다
그림 1-4는 로드밸런서가 어떻게 동작하는지 보여주고 있다.

그림 1-4와 같이, 사용자는 로드밸런서의 공개 IP 주소(publi IP address)로 접속한다.
따라서 웹 서버는 클라이언트의 접속을 직접 처리하지 않는다.
더 나은 보안을 위해, 서버 간 통신에는 사설 IP 주소(private IP address)가 이용된다.
사설 IP 주소는 같은 네트워크에 속한 서버 사이의 통신에만 쓰일 수 있는 IP 주소로,
인터넷을 통해서는 접속할 수 없다.
로드밸런서는 웹 서버와 통신하기 위해 바로 이 사설 주소를 이용한다.

그림 1-4에 나온대로, 부하 분산 집합에 또 하나의 웹 서버를 추가하고 나면
장애를 자동복구하지 못하는 문제(no failover)는 해소되며,
웹 계층의 가용성(availability)은 향상된다.
좀 더 구체적으로 살펴보면 다음과 같다.

1) 서버 1이 다운되면(offline) 모든 트래픽은 서버 2로 전송된다.
   따라서 웹 사이트 전체가 다운되는 일이 방지된다.
   부하를 나누기 위해 새로운 서버를 추가할 수도 있다.

2) 웹사이트로 유입되는 트래픽이 가파르게 증가하면, 
    두 대의 서버로 트래픽을 감당할 수 없는 시점이 오는데,
   로드밸런서가 있으므로 우아하게 대처할 수 있다.
    웹 서버 계층에 더 많은 서버를 추가하기만 하면 된다. 
   그러면 로드밸런서가 자동적으로 트래픽을 분산하기 시작할 것이다.
</details>



-----------------------
### 아키텍처란 무엇인가, 대용량 트래픽을 견뎌낼 만한 아키텍처는 무엇이라고 생각하는가?
<details>
   <summary> 답안 보기 (👈 Click)</summary>
[참고: ]
+  
</details>



-----------------------


Public / Private 클라우드의 차이, IaaS의 의미

Relational DB / NoSQL의 차이점

