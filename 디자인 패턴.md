# 디자인 패턴
<br>



### 싱글턴 패턴이란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+ 오직 하나의 인스턴스만을 제공하는 디자인 패턴을 의미합니다.  
  싱글턴 클래스는 다음과 같이 선언할 수 있습니다. 
  
  
      public class Settings {

        private Settings() {}
    
        public static Settings getInstance(){
    	    return new Settings();
        }
    
      }  
   
 위와 같이 선언하면 문제점은 매번 다른 객체를 생성한다는 점입니다.   
 이 경우 코드를 다음과 같이 수정할 수 있습니다. 
   
      public class Settings{

        private static Settings instance;
    
        private Settings(){}
    
        public static Settings getInstance(){
    	    if(instance == null){
                instance = new Settings();
          }
        
          return instance;
        }
      }

 위와 같이 선언했을 때도 문제가 발생하는데, 멀티스레드 환경에서 안전하지 않다는 점입니다.    
 예를 들어, 두 개의 스레드가 동시에 if(instance == null)에 접근했을 때, 두 개의 객체가 생성될 수 있습니다. <br> 
 이를 해결하기 위한 첫 번째 방법으로는 synchronized 키워드를 통해 메소드를 동기화하는 것입니다. 
 
     public class Settings{

        private static Settings instance;
    
        private Settings(){}
    
        public static synchronized Settings getInstance(){
    	    if(instance == null){
        	    instance = new Settings();
          }
        
            return instance;
        }
    }
   
   
- 위 방법의 단점은 메소드 실행 시 synchronized 처리로 인해, 성능 상 불이익이 발생할 수 있다는 점입니다. 
  이 경우 코드를 다음과 같이 수정할 수 있습니다. 이러한 방식을 이른 초기화(eager initialization)이라고 합니다.
  이 방식은 스레드 안전(thread safe)합니다.  
     
        public class Settings{

        private static final Settings INSTANCE = new Settings();
    
        private Settings(){}
    
        public static Settings getInstance(){     
            return INSTANCE;
        }
        }



</details>

-----------------------

### 싱글턴 패턴을 깨뜨리는 방법과 안전하고 단순하게 구현하는 방법은?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+  
</details>


-----------------------

### 팩토리 메소드 패턴이란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+  
</details>


-----------------------


### 전략 패턴이란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+ 전략 패턴은 '클라이언트가 전략을 생성해 전략을 실행할 컨텍스트에 주입하는 패턴' <br>
  을 의미합니다. 
</details>

-----------------------

### 템플릿 메소드 패턴이란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: 토비의 스프링]
+ 상속을 통해 슈퍼클래스의 기능을 확장할 때, 사용하는 가장 대표적인 방법입니다. <br> 
  변하지 않는 기능은 슈퍼클래스에 만들어두고, 자주 변경되며 확장할 기능은 서브클래스에서 만들도록 합니다. <br> 
  슈퍼 클래스에서는 미리 추상 메소드 또는 오버라이드 가능한 메소드를 정의해두고 <br> 
  이를 활용해 코드의 기본 알고리즘을 담고 있는 템플릿 메소드를 만듭니다. <br> 
  슈퍼클래스에서 디폴트 기능을 정의해두거나 비워뒀다가 서브 클래스에서 선택적으로 오버라이드할 수 있도록 만들어둔 메소드를 <br>
  훅(hook) 메소드라고 합니다. <br>
  서브 클래스에서는 추상 메소드를 구현하거나, 훅 메소드를 오버라이드하는 방법을 이용해 기능의 일부를 확장합니다. <br> 
   
</details>


-----------------------

### 옵저버 패턴이란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: 헤드 퍼스트 디자인 패턴] 
   
+ 옵저버 패턴은 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체에게 연락이 가고 <br>
  자동으로 내용이 갱신되는 방식으로 일대다(one-to-many) 의존성을 정의합니다. <br>
  주제와 옵저버로 일대다 관계가 정의되고, 옵저버는 주제에 딸려 있으며, <br> 
  주제의 상태가 바뀌면 옵저버에게 정보가 전달됩니다. <br>
   
  옵저버 패턴은 여러 가지 방법으로 구현할 수 있지만, 보통은 주제 인터페이스와 옵저버 인터페이스가 들어 있는 <br>
  클래스 디자인으로 구현합니다. 
</details>

-----------------------

### 빌더 패턴이란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+  
</details>

-----------------------

### 프록시 패턴이란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: GOF의 디자인패턴] 
+ 다른 객체에 대한 접근을 제어하기 위한 대리자 또는 자리채움자 역할을 하는 객체를 둡니다. <br> 
   
  어떤 객체에 대한 접근을 제어하는 한 가지 이유는 실제로 그 객체를 사용할 수 있을 때까지 <br> 
  객체 생성과 초기화에 들어가는 비용 및 시간을 물지 않겠다는 것입니다. <br> 
  
  그래픽 객체를 문서 안에 넣을 수 있는 문서 편집기의 예를 다시 생각해 봅시다. <br> 
  래스터(raster) 이미지와 같은 그래픽 객체를 생성하려면 비용이 많이 듭니다. <br> 
  그러나 문서를 읽어내는 것은 이런 그래픽 객체가 있든 없든 매우 빠르게 진행되어야 합니다. <br> 
  또한 문서가 읽히는 그 시점에서 모든 내용을 다 읽어올 필요는 없습니다. <br> 
  이미지의 모든 내용이한꺼번에 한 문서에 다 보일 필요는 없기 때문입니다. <br> 
   
  이런 제약 사항들로 생성이나 관리가 어려운 객체라면 꼭 필요할 때만 
  이 객체를 생성하도록 하는 방법이 제기되었습니다. <br> 
  그러나 이미지가 찍힐 자리에 어떤 내용을 채워넣을 수 있을까요? <br> 
  이 이미지가 필요할 때만 생성된다는 사실을 감추면서 어떻게 전체 편집기의 구현을 복잡하게 만들지 않을 수 있을까요? <br> 
  이런 최적화가 렌더링 혹은 서식 설정 코드에 영향을 주어서도 안됩니다. <br> 
   
  이에 대한 해결책은 실제 이미지의 대역을 맡을 이미지 프록시라는 또 다른 객체를 사용하는 것입니다. <br> 
  프록시는 이미지처럼 동작하고, 필요할 때 이미지의 인스턴스를 만들어냅니다. <br> 
  이미지 프록시는 문서 편집기가 실제로 Draw() 연산을 통해서 화면에 그리기 원할 때만 실제 이미지를 생성합니다. <br> 
  프록시는 자신이 받은 메시지를 실제 이미지에 전달하고, 이미지 생성 후 이미지에 대한 참조를 유지해야 합니다. <br> 
   
  이미지가 다른 파일에 저장되어 있다면, 실제 객체에 대한 참조자로 파일 이름을 관리하면 됩니다. <br> 
  또한, 프록시는 자신이 책임져야 할 이미지의 넓이와 높이를 한계 정보로 관리합니다. <br> 
  이는 이미지의 실제적 인스턴스 없이도 문서가 관리해야 하는 이미지의 크기에 대한 요청을 처리할 수 있게 됩니다. <br>
  즉, 문서를 읽을 때 이미지 자리에 일단 이미지 크기만큼 정보가 있다는 정도는 알려줘야 한다는 것입니다.  
  
  
   
  
</details>
