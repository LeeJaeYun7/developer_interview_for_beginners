# 디자인 패턴
<br>



### 싱글턴 패턴이란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+ 오직 하나의 인스턴스만을 제공하는 디자인 패턴을 의미합니다.  
  싱글턴 클래스는 다음과 같이 선언할 수 있습니다. 
  
  
      public class Settings {

        private Settings() {}
    
        public static Settings getInstance(){
    	    return new Settings();
        }
    
      }  
   
 위와 같이 선언하면 문제점은 매번 다른 객체를 생성한다는 점입니다.   
 이 경우 코드를 다음과 같이 수정할 수 있습니다. 
   
      public class Settings{

        private static Settings instance;
    
        private Settings(){}
    
        public static Settings getInstance(){
    	    if(instance == null){
                instance = new Settings();
          }
        
          return instance;
        }
      }

 위와 같이 선언했을 때도 문제가 발생하는데, 멀티스레드 환경에서 안전하지 않다는 점입니다.    
 예를 들어, 두 개의 스레드가 동시에 if(instance == null)에 접근했을 때, 두 개의 객체가 생성될 수 있습니다. <br> 
 이를 해결하기 위한 첫 번째 방법으로는 synchronized 키워드를 통해 메소드를 동기화하는 것입니다. 
 
     public class Settings{

        private static Settings instance;
    
        private Settings(){}
    
        public static synchronized Settings getInstance(){
    	    if(instance == null){
        	    instance = new Settings();
          }
        
            return instance;
        }
    }
   
   
- 위 방법의 단점은 메소드 실행 시 synchronized 처리로 인해, 성능 상 불이익이 발생할 수 있다는 점입니다. 
  이 경우 코드를 다음과 같이 수정할 수 있습니다. 이러한 방식을 이른 초기화(eager initialization)이라고 합니다.
  이 방식은 스레드 안전(thread safe)합니다.  
     
        public class Settings{

        private static final Settings INSTANCE = new Settings();
    
        private Settings(){}
    
        public static Settings getInstance(){     
            return INSTANCE;
        }
        }



</details>

-----------------------

### 싱글턴 패턴을 깨뜨리는 방법과 안전하고 단순하게 구현하는 방법은?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+  
</details>


-----------------------

### 팩토리 메소드 패턴이란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+  
</details>


-----------------------


### 전략 패턴이란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+ 전략 패턴은 '클라이언트가 전략을 생성해 전략을 실행할 컨텍스트에 주입하는 패턴' <br>
  을 의미합니다. 
</details>

-----------------------

### 템플릿 메소드 패턴이란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: 토비의 스프링]
+ 상속을 통해 슈퍼클래스의 기능을 확장할 때, 사용하는 가장 대표적인 방법입니다. <br> 
  변하지 않는 기능은 슈퍼클래스에 만들어두고, 자주 변경되며 확장할 기능은 서브클래스에서 만들도록 합니다. <br> 
  슈퍼 클래스에서는 미리 추상 메소드 또는 오버라이드 가능한 메소드를 정의해두고 <br> 
  이를 활용해 코드의 기본 알고리즘을 담고 있는 템플릿 메소드를 만듭니다. <br> 
  슈퍼클래스에서 디폴트 기능을 정의해두거나 비워뒀다가 서브 클래스에서 선택적으로 오버라이드할 수 있도록 만들어둔 메소드를 <br>
  훅(hook) 메소드라고 합니다. <br>
  서브 클래스에서는 추상 메소드를 구현하거나, 훅 메소드를 오버라이드하는 방법을 이용해 기능의 일부를 확장합니다. <br> 
   
</details>


-----------------------

### 팩토리 메소드 패턴이란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: 토비의 스프링]
+ 
   
</details>


-----------------------

### 추상 팩토리 패턴이란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: 토비의 스프링]
+ 
   
</details>


-----------------------

### 옵저버 패턴이란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: 헤드 퍼스트 디자인 패턴] 
   
+ 옵저버 패턴은 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체에게 연락이 가고 <br>
  자동으로 내용이 갱신되는 방식으로 일대다(one-to-many) 의존성을 정의합니다. <br>
  주제와 옵저버로 일대다 관계가 정의되고, 옵저버는 주제에 딸려 있으며, <br> 
  주제의 상태가 바뀌면 옵저버에게 정보가 전달됩니다. <br>
   
  옵저버 패턴은 여러 가지 방법으로 구현할 수 있지만, 보통은 주제 인터페이스와 옵저버 인터페이스가 들어 있는 <br>
  클래스 디자인으로 구현합니다. 
   
   
[참고: GoF의 디자인 패턴] 
   
+ 객체 사이에 일대다의 의존관계를 정의해 두어, 어떤 객체의 상태가 변할 때 그 객체에 의존성을 가진 <br> 
  다른 객체들이 그 변화를 통지 받고 자동으로 갱신될 수 있게 만듭니다. <br> 
  다른 이름으로 종속자(Dependent), 게시-구독(Publish-Subscribe)이라고도 합니다. <br> 
  
  어떤 하나의 시스템을 서로 연동되는 클래스 집합으로 분할했을 때, <br>
  발생하는 공통적인 부작용은 관련된 객체 간에 일관성을 유지하도록 해야 한다는 것입니다. <br> 
  그렇다고 이 일관성 관리를 위해서 객체 간의 결합도를 높이고 싶지는 않습니다. <br> 
  그렇게 되면 각 클래스의 재사용성이 떨어지기 때문입니다. <br> 
  
  예를 들어, 많은 그래픽 사용자 인터페이스 툴킷은 표현 부분과 이에 대응하는 데이터를 분리합니다. <br> 
  응용 프로그램 자료와 표현을 정의하는 클래스는 독립적으로 재사용할 수 있습니다. <br> 
  그러나 이들은 함께 동작해야 합니다. <br> 
  예를 들어, 테이블 형태의 객체와 바 형태로 표현된 객체 모두 하나의 동일한 자료 값을 나타내나, <br>
  스프레드 시트와 바는 서로 관련 없는 클래스들이므로 독립적으로 재사용이 가능해야 합니다. <br> 
  만약, 이 독립적 객체가 하나의 정보 값을 표현하는데 함께 사용된다면, <br>
  사용자가 스프레드시트에서 정보를 변경할 때 바에도 이 변경된 정보가 반영되어야 합니다. <br> 
   
  스프레드시트와 바 차트는 데이터 객체에 종속적이기 때문에 그 데이터에 일어난 변경을 통보받아야 합니다. <br> 
  그러나 반드시 이 예처럼 종속적인 객체의 개수가 두 개로 제한되는 것은 아닙니다. <br>
  서로 다른 다수의 사용자 인터페이스가 하나의 데이터에 종속될 수 있습니다. <br> 
   
  감시자 패턴은 이런 관련성을 관리하는 패턴입니다. <br> 
  이 패턴에서 중요한 객체는 주체(subject)와 감시자(observer)입니다. <br> 
  주체는 독립된 여러 개의 감시가 있을 수 있습니다. <br>
  모든 감시자는 주체의 상태 변화가 있을 때마다, 이 변화를 통보 받습니다. <br>
  각 감시자는 주체의 상태와 자신의 상태를 동기화시키기 위해 주체의 상태를 알아봅니다. <br> 
  
  이런 종류의 상호 작용을 게시-구독 관계라고 합니다. <br>
  주체는 상태 변경에 대한 통보를 하는 것이므로, 누가 감시자인지 모른 채 통보를 발송합니다. <br>
  불특정 다수의 감시자가 이 통보를 수신하기 위해서 구독을 신청하는 것입니다. 
   
</details>

-----------------------

### 빌더 패턴이란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+  
</details>

-----------------------

### 프록시 패턴이란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: GOF의 디자인패턴] 
+ 다른 객체에 대한 접근을 제어하기 위한 대리자 또는 자리채움자 역할을 하는 객체를 둡니다. <br> 
   
  어떤 객체에 대한 접근을 제어하는 한 가지 이유는 실제로 그 객체를 사용할 수 있을 때까지 <br> 
  객체 생성과 초기화에 들어가는 비용 및 시간을 물지 않겠다는 것입니다. <br> 
  
  그래픽 객체를 문서 안에 넣을 수 있는 문서 편집기의 예를 다시 생각해 봅시다. <br> 
  래스터(raster) 이미지와 같은 그래픽 객체를 생성하려면 비용이 많이 듭니다. <br> 
  그러나 문서를 읽어내는 것은 이런 그래픽 객체가 있든 없든 매우 빠르게 진행되어야 합니다. <br> 
  또한 문서가 읽히는 그 시점에서 모든 내용을 다 읽어올 필요는 없습니다. <br> 
  이미지의 모든 내용이한꺼번에 한 문서에 다 보일 필요는 없기 때문입니다. <br> 
   
  이런 제약 사항들로 생성이나 관리가 어려운 객체라면 꼭 필요할 때만 
  이 객체를 생성하도록 하는 방법이 제기되었습니다. <br> 
  그러나 이미지가 찍힐 자리에 어떤 내용을 채워넣을 수 있을까요? <br> 
  이 이미지가 필요할 때만 생성된다는 사실을 감추면서 어떻게 전체 편집기의 구현을 복잡하게 만들지 않을 수 있을까요? <br> 
  이런 최적화가 렌더링 혹은 서식 설정 코드에 영향을 주어서도 안됩니다. <br> 
   
  이에 대한 해결책은 실제 이미지의 대역을 맡을 이미지 프록시라는 또 다른 객체를 사용하는 것입니다. <br> 
  프록시는 이미지처럼 동작하고, 필요할 때 이미지의 인스턴스를 만들어냅니다. <br> 
  이미지 프록시는 문서 편집기가 실제로 Draw() 연산을 통해서 화면에 그리기 원할 때만 실제 이미지를 생성합니다. <br> 
  프록시는 자신이 받은 메시지를 실제 이미지에 전달하고, 이미지 생성 후 이미지에 대한 참조를 유지해야 합니다. <br> 
   
  이미지가 다른 파일에 저장되어 있다면, 실제 객체에 대한 참조자로 파일 이름을 관리하면 됩니다. <br> 
  또한, 프록시는 자신이 책임져야 할 이미지의 넓이와 높이를 한계 정보로 관리합니다. <br> 
  이는 이미지의 실제적 인스턴스 없이도 문서가 관리해야 하는 이미지의 크기에 대한 요청을 처리할 수 있게 됩니다. <br>
  즉, 문서를 읽을 때 이미지 자리에 일단 이미지 크기만큼 정보가 있다는 정도는 알려줘야 한다는 것입니다.  
  
  
   
  
</details>
