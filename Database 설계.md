# Database 설계
<br>

### DB 설계가 중요한 이유는 무엇인가?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: 관계형 데이터베이스 실전 입문] 
  
+ 객체지향 프로그래밍을 해 본 경험이 있는 사람이라면 데이터와 작업이 세트여야 하는 것을 이해하고 있을 것입니다. <br> 
  적절한 객체가 설계되어 있지 않다면, 그에 대한 조작인 멤버함수나 메서드는 복잡해질 것이며, <br> 
  응용 프로그램의 로직도 잘 표현할 수 없을 것입니다. <br> 
  관계형 모델에서도 마찬가지입니다. 데이터의 조작인 쿼리는 DB에 포함된 각 테이블이 적절히 설계되어 있지 않으면, <br>
  깔끔하게 표현할 수 없습니다. <br> 
  
  그러나 걱정할 필요는 없습니다. 관계형 모델의 세계에는 왕도라고 불리는 DB 설계 이론이 있습니다. <br> 
  그것이 정규화 이론(Normalization theory)입니다. <br> 
  
  정규화는 RDB를 사용하는데 있어 매우 중요한 개념입니다. <br> 
  그러나 정규화에 관해 정확하게 이해하고 있지 않다고 생각합니다. <br> 
  정규화에 관한 설명은 매우 많지만, 알기 쉬우면서 직관적으로 설명된 것은 거의 없습니다. <br> 
  
  또한, 정규화에 관한 틀린 설명도 많이 있습니다. 그 때문인지 모르겠지만, 정규화가 잘 구현돼 있지 않은 것이 현실입니다. <br> 
  오히려 릴레이션의 정규화는 "딱히 필요 없는 것"이라고 무시하거나, "정규화는 잘 모르겠지만, 지금 상태로도 움직이고 있고 괜찮을 거야"라고 <br>
  방치되기에 십상입니다. <br> 

</details>

-----------------------


### 정규화란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: 관계형 데이터베이스 실전 입문] 
  
+ 정규화 이론은 RDB에서 왕도라고 할 수 있는 DB의 설계 이론입니다. <br> 
  그러나 사실은 정규화 이론이 관계형 모델의 일부는 아닙니다. <br> 
  관계형 모델 자체는 릴레이션이 정규화되어 있지 않아도 동일하게 처리할 수 있습니다. <br> 
  다만, 이는 똑같이 릴레이션의 연산을 적용할 수 있다는 의미이며, <br> 
  정규화되어 있지 않은 릴레이션이 취급하기 쉽다는 의미는 아닙니다. <br> 
  물론 정규화를 하는 편이 좋은 DB 설계라고 할 수 있습니다. 
  
  정규화 이론은 RDB를 잘 다루는데 필요한 기술이며, 관계형 모델을 전제로 구축된 DB 설계 이론입니다. <br> 
  위치적으로는 관계형 모델을 바탕으로 하고, 관계형 모델을 보완하는 이론입니다. 
</details>

-----------------------


### 릴레이션을 정규화하면 어떤 점이 좋아지나요?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: 관계형 데이터베이스 실전 입문] 
  
+ 정규화의 이점은 몇 가지가 있지만, 가장 중요한 것은 모순을 방지할 수 있다는 것입니다. <br> 
  모순이란 데이터가 논리적인 불일치가 일어나는 상태를 말합니다. <br> 
  또한, 모순이 발생한 상태를 변칙(Anomalies)이라고 합니다. <br>
  변칙을 방지할 수 있는 것이 정규화가 맡은 가장 큰 역할입니다. <br> 
</details>

-----------------------

### 모순이 발생한 상태란 무엇입니까?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: 관계형 데이터베이스 실전 입문] 
  
+ 변칙이 생기는 예는 다음과 같습니다. <br> 
  아래 그림은 가상의 IT계 학교에서 학생과 이번 학기의 수업의 이수를 나타낸 릴레이션입니다. <br> 
  이 릴레이션에는 이름, 수업, 학년 세 가지 속성이 있습니다. <br> 
  ![image](https://user-images.githubusercontent.com/8718430/206895817-7e802be7-bdf7-47a6-b7d7-a3ca935bebde.png)

  그림 3.1의 릴레이션의 어디에서 모순이 생기는 걸까? <br> 
  이 릴레이션에 나오는 3명 중의 1명인 오민혁에 주목합니다. <br>
  오민혁의 학년 속성에는 두 개의 다른 값이 포함되어 있습니다. <br> 
  
  같은 사람에 대한 학년은 같은 값이어야 합니다. 그러나 이 릴레이션에서는 값이 다릅니다. <br> 
  이것은 명백한 모순입니다. 이 릴레이션만 보고 "오민혁의 학년이 1학년인지 2학년인지 명확하게 판단할 수 있을까?"처럼 <br> 
  답이 나올 수 없는 질문은 하지 않겠습니다. <br> 
  
  사실은 이러한 모순이 있으면 아무리 생각해도 정답이 나오지 않습니다. <br> 
  논리적으로 모순이기 때문입니다. <br> 
  릴레이션은 명제가 참인 집합이라고 이미 설명했지만, <br> 
  릴레이션이 나타내는 것은 "어느 쪽의 사실도 맞다"입니다. <br> 
  맞는 사실이 엇갈리므로 모순이 생기는 것입니다. <br>
  이처럼 모순이 생기는 상태가 변칙입니다. 
  
  
</details>

-----------------------

### 변칙이 발생하는 이유는 무엇입니까?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: 관계형 데이터베이스 실전 입문] 
  
+ 사실은 관계형 모델에서 변칙을 일으키는 범인은 명확히 알고 있습니다. <br> 
  그것은 중복입니다. <br> 
  중복이란 글자 그대로 한 개의 릴레이션에 같은 데이터가 여러 개 존재하는 것을 말합니다. <br> 
  그림 3.1은 각 학생의 학년이 같지만 여러 번 나오고 있습니다. <br> 
  이처럼 중복이 있으면 변칙이 발생할 수 있습니다. <br>
   
  중복이 있으면 사소한 갱신의 실수로 모순이 생깁니다. <br> 
  예를 들어, 이것이 SQL의 테이블이라면 정은오의 학년을 한 개의 행만 3으로 업데이트하면 어떻게 될까?<br>
  이 때도 역시 모순이 생겨 정은오의 학년이 2학년인지 3학년인지 알 수 없게 되어 버립니다. <br> 
  
  이와 같은 모순의 원인은 중복입니다. <br> 
  그러므로 모순이 생기지 않게 하려면 중복을 제거하면 됩니다. <br> 
  이런 중복을 제거하는 작업을 시행하는데 도움이 되는 것이 이번 장의 주제인 정규화 이론입니다. <br> 
  
  
</details>

-----------------------


### 정규형이란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: 관계형 데이터베이스 실전 입문] 
  
+ 정규화의 취지를 이해했으므로, 구체적인 작업에 관해 설명합니다. <br> 
  정규화에는 몇 가지 단계가 있고, 높은 단계로 갈수록 더 좋은 상태(앞에서 설명한 중복이 적은 상태)가 됩니다. <br> 
  정규화의 각 단계는 정규형(Normal Form, NF)라고 합니다. <br> 
   
  정규형의 종류에는 제1정규형, 제2정규형, 제3정규형, 보이스코드 정규형(BCNF) 등이 있습니다. <br>
   
  정규형의 중요한 특징 중 하나는 높은 단계의 정규형은 자동으로 그 이전의 정규형 조건을 만족한다는 것입니다. <br> 
  예를 들어, BCNF의 릴레이션은 1NF~3NF의 조건을 만족하고, <br>
  5NF의 릴레이션은 1NF~4NF의 조건을 모두 만족합니다. <br> 
   
  DB 설계에서 중요한 것은 BCNF와 5NF입니다. <br> 
  그 외의 정규형은 역사적인 이유 때문에 남아 있을 뿐, 그것을 목표로 하는 정규화는 거의 없습니다. <br> 
  일반화된 종속성이라는 개념을 사용해 정규화를 실시하므로 BCNF와 5NF 이외의 정규화는 생각하지 않아도 됩니다. 
  
  
</details>

-----------------------


### 제1 정규형이란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: 관계형 데이터베이스 실전 입문] 
  
+ 1NF는 정규화의 출발점입니다. 1NF를 하기 위한 요건은 '릴레이션이어야 할 것'입니다. <br>
  이는 관계형 모델이 아니고, SQL에 적용되는 조건입니다. <br> 
  관계형 모델에서는 모든 릴레이션이 1NF의 요건을 충족하는 것이 원칙입니다. <br> 
   
  1장에서 SQL과 관계형 모델의 차이를 설명했습니다. <br> 
  SQL에서는 테이블이 1NF이기 위해 갖춰야 할 몇 가지 조건이 있습니다. <br> 
  즉, SQL에서 테이블이 릴레이션인 것이 어떤 것인지가 1NF의 주제입니다. <br> 
   
  테이블이 1NF가 되기 위한 요건은 다음과 같습니다. <br> 
  (1) 행이 위에서 아래로 정렬돼 있지않다 <br>
  (2) 열이 왼쪽에서 오른쪽으로 정렬돼 있지 않다. <br> 
  (3) 중복하는 행이 존재하지 않는다. <br> 
  (4) 각 행과 열의 교차점(즉, 열의 값)은 도메인(데이터형)에 속하는 요소의 값을 딱 한 개만 가진다. <br> 
  (5) 모든 열의 값은 정의된 것이어야 하고, 각 행은 항상 존재한다. <br> 
  
  
</details>

-----------------------

### 칼럼이나 행의 순서는 무엇인가?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: 관계형 데이터베이스 실전 입문] 
  
+ 사실 SQL의 사양으로 테이블의 칼럼에 순서가 존재합니다. <br> 
  따라서 엄밀히 말하면 테이블은 1NF의 조건을 만족하지 않습니다. <br> 
  그러나 이 점은 실제로는 문제가 되지 않게 할 수 있습니다. <br> 
   
  이를 위해서 필요한 것은 칼럼이나 행의 위치에 의존하는 쿼리를 작성하지 않는 것입니다. <br> 
  사양 상 테이블의 칼럼이나 행에 순서가 있더라도, 그 순서에 의존하는 처리를 사용하지 않으면 문제가 되지 않기 때문입니다. <br> 
  
  칼럼의 순서에 의존하는 처리는 다음과 같은 것들이 있습니다. <br>
  (1) SELECT *로 모든 칼럼의 값을 검색하고, 응용 프로그램이 칼럼의 위치에 따라 데이터에 접근하는 것 <br>
  (2) ORDER BY 절의 인수로 select list 내에서 칼럼의 위치를 지정하는것(ex) ORDER BY 1) 
   
  또한, DBMS에 따라서는 칼럼뿐 아니라 행의 순서가 있는 것도 있습니다. <br> 
  예를 들어, ROWID나 OjectID 같은 것이 그 예입니다. <br> 
  1NF의 요건을 충족시키려면 이러한 기능을 사용해서는 안됩니다. <br> 
  
</details>

-----------------------

### 중복되는 행을 제거한다는 것이 무엇인가?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: 관계형 데이터베이스 실전 입문] 
  
+ 단순히 '똑같은 행의 값이 최대 1개 이상 포함되지 않으면 된다'입니다. <br> 
  테이블에 기본키나 유니크키처럼 고유성 제약 조건을 붙이면 됩니다. <br> 
  
  다만 중요한 것은 제약 그 자체가 아니라 실제로 저장되는 값이 중복되지 않게 한다는 점에 유의합니다. <br> 
  실제로 중복되지 않으면 제약이 있든 없든 관계형 모델은 성립합니다. <br> 
  지속해서 운영하면서 시시각각 내용이 변하는 테이블에 값이 중복되지 않도록 보장하기 위해 제약을 사용합니다. <br> 
   
  그런데 오해하기 쉬운 게 '행이 중복되지 않으면 그걸로 정규화가 됐다'라고 생각하는 것입니다. <br> 
  고유성 제약 조건을 걸어서 해결되는 거라면 간단하지만, 정규화는 그렇게 단순하지 않습니다. <br> 
  테이블에 포함된 행이 행 전체로는 모두 다른 값이어도 테이블에 중복이 발생할 수 있습니다. <br> 
  그렇더라도 중복하는 행을 반드시 제거해야 합니다. <br> 
  
</details>

-----------------------

### NULL이 포함되면 안된다는 것이 무엇인가?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: 관계형 데이터베이스 실전 입문] 
  
+ 1장에서도 다뤘지만, NULL이 포함돼 있으면 관계형 모델이 무너집니다. <br> 
  따라서 테이블의 모든 행, 모든 칼럼은 구체적인 값을 가져야 합니다. <br> 
  
  하지만 테이블에 NULL이 포함되지 않게 하려면 단순하게 NOT NULL 제약을 걸어서 되는 문제가 아닙니다. <br> 
  지금 현재 NULL인 칼럼에 NOT NULL 제약을 걸면, 응용 프로그램이 그 칼럼의 값이 불분명하다고 판단하므로 <br> 
  기본값을 할당할 뿐입니다. <br> 
   
  예를 들어, 나이를 나타내는 칼럼이라면 NULL 대신에 현실적으로는 불가능한 -1이나 <br> 
  1000과 같은 값을 넣어도 괜찮다고 생각할 수도 있습니다. <br> 
  물론 이런 설계는 잘못된 것입니다. <br> 
  이러한 임시방편적인 대응은 NULL의 폐해를 없애기는 커녕 오히려 응용 프로그램의 로직을 더욱 복잡하게 할 뿐입니다. <br> 
  다른 값으로 대체하는 정도로 대처하려면 NOT NULL 제약을 걸지 않는 편이 낫습니다. <br> 
   
  그럼 어떻게 하는 것이 좋을까? <br> 
  가장 좋은 방법은 테이블을 나누는 것입니다. <br> 
  응용프로그램이 처리 내용에 대해 필요할 때에, 필요한 테이블에 데이터를 저장합니다. <br> 
  칼럼의 값이 NULL이라는 것은 응용 프로그램이 아직 그 데이터가 필요하지 않기 때문이므로, <br> 
  다른 단계에 필요한 데이터라고 생각합니다. <br> 
  따라서 아직 그 테이블에는 그 칼럼이 있을 필요가 없습니다. <br> 
   
</details>

-----------------------

### 역정규화란 무엇입니까?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: https://ko.wikipedia.org/wiki/%EC%97%AD%EC%A0%95%EA%B7%9C%ED%99%94] 
  
+ 역정규화는 이전에 정규화된 데이터베이스에서 성능을 개선하기 위해 사용되는 전략입니다. <br>
  일부 쓰기 성능의 손실을 감수하고, 데이터를 묶거나 데이터의 복제 사본을 추가함으로써 <br>
  데이터베이스의 읽기 성능을 개선하려고 시도하는 과정입니다. <br>
   
  아주 많은 수의 읽기 작업을 처리할 필요가 있는 관계형 데이터베이스 소프트웨어의 성능이나 스케일링에서 고렫됩니다. <br> 
  데이터베이스/테이블은 이들을 효율적으로 역정규화하기 위해 우선 정규화되어야 합니다. <br> 
   
</details>

-----------------------
