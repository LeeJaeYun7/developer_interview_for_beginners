# Database
<br>

-----------------------
### RDB vs NoSQL?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+ RDB
    - RDB는 테이블 형식의 고정된 스키마를 제공합니다. 
    - RDB는 테이블 간 Join문을 제공합니다.
    - RDB는 트랜잭션 기능을 제공합니다.
    - RDB는 엄격한 Schama로 데이터 중복이 없기 때문에 update가 많은 경우에 유리합니다. 
    - RDB는 Scale-up에 유리합니다. 

+ NoSQL
    - NoSQL은 다양한 형식으로 저장됩니다.(ex) Key-value, Graph-based, Column-based 등)
    - NoSQL은 일반적으로 Join문을 제공하지 않습니다. 
    - NoSQL은 일반적으로 트랜잭션 기능을 제공하지 않습니다. 
    - NoSQL은 빠른 읽기 성능을 가지고 있으므로, 일반적으로 많은 데이터를 읽는 서비스에 유리합니다. 
    - NoSQL은 Scale-out에 유리합니다. 

</details>

-----------------------

### MySQL 엔진은 무엇으로 구성되어 있나요?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+ MySQL 엔진은 클라이언트로부터의 접속 및 쿼리 요청을 처리하는 커넥션 핸들러, <br> 
  SQL 파서 및 전처리기,<br>
  쿼리의 최적화된 실행을 위한 옵티마이저가 중심을 이룹니다. 

</details>

-----------------------

### 스토리지 엔진의 기능은 무엇인가요?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+ 스토리지 엔진은 실제 데이터를 디스크 스토리지에 저장하거나, <br>
  디스크 스토리지로부터 데이터를 읽어오는 부분을 전담합니다. <br>
  MySQL 서버에서 MySQL 엔진은 하나지만, 스토리지 엔진은 여러 개를 동시에 사용할 수 있습니다. <br> 
  각 스토리지 엔진은 성능 향상을 위해 InnoDB 버퍼 풀(InnoDB 스토리지 엔진), 키 캐시(MyISAM 스토리지 엔진) <br>
  과 같은 기능을 내장하고 있습니다.  
   

</details>

-----------------------


### MySQL 스레딩 구조는 어떻습니까?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+ MySQL 서버는 프로세스 기반이 아니라 스레드 기반으로 동작하며, <br>
  크게 포그라운드(Foreground) 스레드와 백그라운드(Background) 스레드로 구분할 수 있습니다. <br>
  백그라운드 스레드의 개수는 MySQL 서버의 설정 내용에 따라 가변적일 수 있습니다. <br> 
  포그라운드 스레드는 최소한 MySQL 서버에 접속된 클라이언트의 수만큼 존재하며, <br>
  주로 각 클라이언트 사용자가 요청하는 쿼리 문장을 처리합니다. <br> 
   
</details>

-----------------------

### MySQL 스레드 캐시는 어떻게 동작합니까?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+ 클라이언트사용자가 작업을 마치고, 커넥션을 종료하면 해당 커넥션을 담당하던 스레드는<br>
  다시 스레드 캐시(Thread Cache)로 되돌아갑니다.<br>
  이 때, 이미 스레드 캐시에 일정 개수 이상의 대기 중인 스레드가 있으면, <br>
  스레드 캐시에 넣지 않고 스레드를 종료시켜 일정 개수의 스레드만 스레드 캐시에 존재하게 합니다.<br>
  이 때, 스레드 캐시에 유지할 수 있는 최대 스레드 개수는 thread_cache_size 시스템 변수로 설정합니다. 
   
</details>

-----------------------

### 트랜잭션이란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+ 

</details>

-----------------------

### 인덱스의 장단점은?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+ 장점
    - 인덱스는 일종의 색인으로서, 매우 빠른 검색을 가능하게 한다는 점이 장점입니다. 

+ 단점
    - 인덱스는 데이터를 업데이트하거나 삭제할 때, 매번 정렬을 해줘야 하므로,
      업데이트 및 삭제의 성능은 떨어질 수 있다는 단점이 있습니다. 

</details>

-----------------------
### Hash Index 알고리즘의 장점과 단점은?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

-----------------------
+ 장점
    - Hash Index 알고리즘은 해시 값을 인덱싱하므로, 매우 빠른 검색을 지원합니다.  
+ 단점
    - 값을 변형하여 저장하므로, 전방(Prefix) 검색과 같은 것에 사용이 불가능합니다.
</details>

-----------------------

### 클러스터링 인덱스는?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+ 프라이머리 키 값이 비슷한 레코드끼리 묶어서 저장하는 것을 클러스터링 인덱스라고 표현합니다. <br>
  즉, 프라이머리 키 값에 의해 레코드의 저장 위치가 결정되며, 프라이머리 키 값이 변경된다면 <br>
  그 레코드의 물리적인 저장 위치도 바뀌어야 합니다. <br>
  클러스터링 인덱스는 테이블의 프라이머리 키에 대해서만 적용되는 내용이며, <br> 
  주로 비슷한 값들을 동시에 조회하는 경우가 많다는 점에 착안한 것입니다. <br>
</details>

-----------------------
### 정규화란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+ 정규화란 하나의 릴레이션에 하나의 의미만 존재할 수 있도록 릴레이션을 분해해 나가는 과정을 의미합니다. <br> 
  반면, 비정규형은 하나의 튜플에서 속성을 입력되는 도메인 값으로 여러 개의 값이 들어와서, 원자성을 갖지 못하는 경우를 의미합니다. <br>
  제1 정규화란 원자값이 아닌 도메인을 분해하여 어떤 릴레이션 R에 속한 모든 도메인이 원자값으로만 설계하는 것을 의미합니다. <br> 
   
  제2 정규형은 어떤 릴레이션 R이 제1정규화에 속하고, 기본키에 속하지 않는 모든 속성이 기본키에 완전 함수적 종속이면 충족하는 정규화 <br> 
   
  제3 정규형은 어떤 릴레이션 R이 제2정규화에 속하고, 기본키에 속하지 않는 모든 속성이 기본키에 이행적 함수 종속이 아닌 상태의 관계 <br> 
 
[참고: SQL 첫걸음] 
+ 정규화란 데이터베이스의 테이블을 규정된 올바른 형태로 개선해나가는 것입니다. <br> 
  정규화는 데이터베이스의 설계 단계에서 행해집니다. <br> 
  경우에 따라서는 기존 시스템을 재검토할 때 정규화하는 경우도 있습니다. <br> 
   
  여기서 말하는 올바른 형태란 주관적 기준이라 할 수 있습니다. <br> 
  정규화의 순서는 이전의 데이터베이스 기술자들이 고안해 정리한 것입니다. <br> 
  이를 참고하여 정규화하는 과정을 통해 관계형 데이터베이스가 효율적으로 동작하도록 <br> 
  만들 수 있습니다. <br> 
  
</details>

-----------------------

### 제1 정규형이란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
   
[참고: SQL 첫걸음] 
+ 관계형 데이터베이스의 테이블에는 하나의 셀에 하나의 값만 저장할 수 있다는 제약이 있습니다. <br> 
  이로 인해 주문상품의 데이터를 그대로 테이블로 만들 수는 없습니다. <br>
  적어도 상품 코드와 상품명, 개수 데이터를 담는 세 개의 열로 나누어야 합니다. <br> 

  제1정규화에서는 중복을 제거하는 테이블의 분할도 이루어집니다. <br> 
  예를 들면, 한 번의 주문으로 여러 개의 상품을 주문할 수 있으므로, <br> 
  주문번호, 날짜, 성명, 연락처가 동일한 값을 가지는 행이 여러 개 존재할 수 있습니다. <br> 
  이 때, 동일한 값을 가지는 행이 여러 개 존재하지 않도록 하나로 정리해야 합니다. <br> 
   
  즉, 제1정규화에서는 반복된 부분을 찾아내서 테이블을 분할하고, <br>
  기본키가 될 열을 작성할 수 있습니다. 
   
</details>

-----------------------


### 제2 정규형이란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
   
[참고: SQL 첫걸음] 
+ 제1정규화에서 테이블에 기본키를 작성한 것과 같은 방법으로, <br> 
  제2정규화에서는 데이터가 중복하는 부분을 찾아내어, 테이블로 분할해 나갑니다. <br> 
  이 때, 기본키에 의해 특정되는 열과 그렇지 않은 열로 나누는 것으로 정규화가 이루어집니다. <br> 
   
  주문상품 테이블을 살펴보면, 주문상품의 기본키는 주문번호와 상품코드의 두 개의 열로 되어 있습니다. <br> 
  주문번호 1에 상품코드가 0001인 상품 주문량은 총 1개라는 것을 알 수 있습니다. <br> 
  이것은 기본키를 바탕으로 특정되는 데이터입니다. <br> 
   
  즉, 개수 열은 기본키가 결정되고 나면 특정할 수 있는 것입니다. <br> 
  한편, 상품명은 주문번호와 관계없이 상품코드만으로 특정할 수 있습니다. <br> 
  상품코드는 기본키의 일부이긴 하지만 단독으로 기본키 역할을 할 수는 없습니다. <br>
   
  이처럼 두 가지로 분류할 수 있으므로, 두 개의 테이블로 분할하겠습니다. <br> 
  테이블명은 '상품'이라고 하겠습니다. <br> 
  
  상품 테이블은 상품코드만으로 기본키를 지정했습니다. <br>
  어려운 말로 표현하자면 부분 함수종속성을 찾아내서 테이블을 분할하는 것이 제2정규화입니다. <br>
  여기서 함수종속성이란 키 값을 이용해 데이터를 특정지을 수 있는 것을 가리킵니다. <br>  
   
</details>

-----------------------


### 부분 함수적 종속성이란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
   
[참고: ] 
+ 
</details>

-----------------------

### 제3 정규형이란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
   
[참고: SQL 첫걸음] 
+ 제3 정규화 또한 중복하는 부분을 찾아내어, 테이블을 분할하는 수법입니다. <br> 
  제2정규화의 경우에는 기본키에 중복이 없는지 조사했습니다만, 제3정규화에서는 기본키 이외의 부분에서 중복이 없는지를 조사합니다. <br> 
  
  분할하기 전의 주문 테이블을 살펴보면 데이터가 중복되어 있습니다. <br> 
  같은 사람이 여러 번 주문하는 경우가 있기 때문입니다. <br> 
  이 때, 주문 테이블에서 이름을 기준으로 연락처를 특정지을 수 있습니다. <br> 
  단, 주문 테이블의 기본키는 어디까지나 주문번호로, 이름은 기본키와는 관계가 없습니다. <br>
  한편 분할하여 새로 만들 테이블의 이름은 '고객'이라 붙였습니다. <br>
  
  여기서도 이름을 기본키로 지정하면 동명이인의 경우 데이터를 제대로 저장할 수 없으므로, <br>
  고객번호를 기본키로 지정하여 고객 테이블을 작성했습니다. 
  
   
</details>

-----------------------

### Connection pool이란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+ 애플리케이션의 스레드에서 데이터베이스에 접근하기 위해 Connection이 필요함 <br>
  데이터베이스와 Connection 객체들을 미리 생성해 Pool에 저장해 두었다가, 클라이언트의 요청이 들어올때마다 <br>
  사용/반환하는 방식을 의미합니다.
   
  Connection Pool의 데이터베이스 접근 과정은 다음과 같습니다. <br>
  (1) 웹 컨테이너가 실행되면 데이터베이스와 연결된 Connection 객체들을 미리 생성해 Pool에 저장 <br>
  (2) 클라이언트 요청 시 Pool에서 Connection 객체를 가져와 데이터베이스 접근 
  (3) 요청 처리가 끝나면 사용된 Connection 객체를 다시 Pool에 반환
   
  Connection Pool의 장점은 다음과 같습니다.
  (1) 매 연결마다 Connection 객체를 생성/제거하는 비용이 감소합니다. 
  (2) 미리 생성된 Connection 객체를 사용하믈모 데이터베이스 접근 시간을 단축합니다. 
  (3) Connection 수를 제한해 부하를 조정할 수 있습니다. 
   
  Connection Pool의 단점은 다음과 같습니다. 
  (1) Connection 또한 객체이므로 메모리를 차지합니다. 
  (2) Connection 개수를 잘못 설정할 경우, 쓸모없는 Connection이 발생할 수 있습니다. 
   
  Connection이 부족할 경우 
  (1) 모든 Connection이 요청을 처리 중일 때, 해당 클라이언트의 요청을 대기 상태로 전환합니다.
  (2) Pool에 Connection 객체가 반환되면 순차적으로 요청을 처리합니다.  
</details>

-----------------------

### 실행 계획은?

<details>
   <summary> 답안 보기 (👈 Click)</summary> (작성중)
<br />

+ 
</details>

-----------------------

### 샤딩이란?

<details>
   <summary> 답안 보기 (👈 Click)</summary> (작성중)
<br />
+ https://aws.amazon.com/ko/what-is/database-sharding/
+ 데이터베이스 샤딩은 대규모 데이터베이스를 여러 머신에 저장하는 프로세스입니다. <br>
  단일 머신 또는 데이터베이스 서버는 제한된 양의 데이터만 저장하고 처리할 수 있습니다. <br> 
  데이터베이스 샤딩은 데이터를 샤드라고 하는 더 작은 정크로 분할하고, <br>
  여러 데이터베이스 서버에 저장함으로써 이러한 한계를 극복합니다.<br> 
  모든 데이터베이스 서버의 기본 기술은 일반적으로 동일하며 함께 작동하여 데이터를 저장하고 처리합니다. <br>
    
+ 애플리케이션이 성장함에 따라 애플리케이션 사용자 수와 애플리케이션에 저장되는 데이터의 양도 시간이 갈수록 증가합니다. <br> 
  데이터 볼륨이 너무 커지고 애플리케이션을 사용하여 동시에 정보를 읽거나 저장하려고 하는 사용자가 너무 많아지면 <br>
  데이터베이스에서 병목 현상이 발생합니다. <br> 
  이로 인해 애플리케이션 속도가 느려지고, 고객 경험에 영향을 미치게 됩니다. <br>
  이에 대한 솔루션의 하나로, 여러 샤드에서 더 작은 데이터 세트를 병렬로 처리하는 데이터베이스 샤딩을 사용하면 이 문제를 해결할 수 있습니다. <br> 
   
+ 데이터베이스 샤딩의 이점은 다음과 같습니다. 
  (1) 응답 시간 개선
  - 대규모의 단일 데이터베이스에서는 데이터를 검색하는데 시간이 더 오래 걸립니다. <br> 
    데이터베이스 관리 시스템은 올바른 데이터를 찾기 위해 여러 행을 검색해야 합니다. <br> 
    그에 비해 데이터 샤드는 전체 데이터베이보다 행 수가 적습니다. <br> 
    따라서 샤딩된 데이터베이스에서는 특정 정보를 검색하거나 쿼리를 실행하는데 걸리는 시간이 단축됩니다. <br>
   
  (2) 전체 서비스 중단 방지 
  - 데이터베이스를 호스팅하는 컴퓨터에서 장애가 발생하면 데이터베이스를 사용하는 어플리케이션에서도 오류가 발생합니다. <br> 
    데이터베이스 샤딩은 데이터베이스의 일부를 다른 컴퓨터에 배포함으로써 이 같은 문제를 방지합니다. <br>
    컴퓨터 중 하나에서 장애가 발생하더라도 정상 작동하는 다른 샤드를 사용하여 작동할 수 있으므로 애플리케이션이 중단되지 않습니다.<br> 
    즉, 샤드 중 하나를 사용할 수 없게 되더라도 대체 샤드에서 데이터에 액세스하고 복원할 수 있습니다. <br> 
     
  (3) 효율적인 크기 조정 
  - 데이터베이스가 확장되면 더 많은 컴퓨팅 리소스를 소비하고, 결국 스토리지의 최대 용량에 도달하게 됩니다. <br>
    이 경우 조직은 데이터베이스 샤딩을 사용하여 더 많은 컴퓨팅 리소스를 추가함으로써 데이터베이스의 확장을 지원할 수 있습니다. <br> 
    유지 관리를 위해 애플리케이션을 종료하지 않고도 런타임에 새 샤드를 추가할 수 있습니다.  
   
</details>

-----------------------
