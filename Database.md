# Database
<br>

-----------------------
### RDB vs NoSQL?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+ RDB
    - RDB는 테이블 형식의 고정된 스키마를 제공합니다. 
    - RDB는 테이블 간 Join문을 제공합니다.
    - RDB는 트랜잭션 기능을 제공합니다.
    - RDB는 엄격한 Schama로 데이터 중복이 없기 때문에 update가 많은 경우에 유리합니다. 
    - RDB는 Scale-up에 유리합니다. 

+ NoSQL
    - NoSQL은 다양한 형식으로 저장됩니다.(ex) Key-value, Graph-based, Column-based 등)
    - NoSQL은 일반적으로 Join문을 제공하지 않습니다. 
    - NoSQL은 일반적으로 트랜잭션 기능을 제공하지 않습니다. 
    - NoSQL은 빠른 읽기 성능을 가지고 있으므로, 일반적으로 많은 데이터를 읽는 서비스에 유리합니다. 
    - NoSQL은 Scale-out에 유리합니다. 

</details>

-----------------------

### MySQL 엔진은 무엇으로 구성되어 있나요?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+ MySQL 엔진은 클라이언트로부터의 접속 및 쿼리 요청을 처리하는 커넥션 핸들러, <br> 
  SQL 파서 및 전처리기,<br>
  쿼리의 최적화된 실행을 위한 옵티마이저가 중심을 이룹니다. 

</details>

-----------------------

### 스토리지 엔진은 무엇으로 구성되어 있나요?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+ 스토리지 엔진은 실제 데이터를 디스크 스토리지에 저장하거나, <br>
  디스크 스토리지로부터 데이터를 읽어오는 부분을 전담합니다. <br>
  MySQL 서버에서 MySQL 엔진은 하나지만, 스토리지 엔진은 여러 개를 동시에 사용할 수 있습니다. <br> 
  각 스토리지 엔진은 성능 향상을 위해 InnoDB 버퍼 풀(InnoDB 스토리지 엔진), 키 캐시(MyISAM 스토리지 엔진) <br>
  과 같은 기능을 내장하고 있습니다.  
   

</details>

-----------------------


### MySQL 스레딩 구조는 어떻습니까?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+ MySQL 서버는 프로세스 기반이 아니라 스레드 기반으로 동작하며, <br>
  크게 포그라운드(Foreground) 스레드와 백그라운드(Background) 스레드로 구분할 수 있습니다. <br>
  백그라운드 스레드의 개수는 MySQL 서버의 설정 내용에 따라 가변적일 수 있습니다. <br> 
  포그라운드 스레드는 최소한 MySQL 서버에 접속된 클라이언트의 수만큼 존재하며, <br>
  주로 각 클라이언트 사용자가 요청하는 쿼리 문장을 처리합니다. <br> 
   
</details>

-----------------------

### MySQL 스레드 캐시는 어떻게 동작합니까?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+ 클라이언트사용자가 작업을 마치고, 커넥션을 종료하면 해당 커넥션을 담당하던 스레드는<br>
  다시 스레드 캐시(Thread Cache)로 되돌아갑니다.<br>
  이 때, 이미 스레드 캐시에 일정 개수 이상의 대기 중인 스레드가 있으면, <br>
  스레드 캐시에 넣지 않고 스레드를 종료시켜 일정 개수의 스레드만 스레드 캐시에 존재하게 합니다.<br>
  이 때, 스레드 캐시에 유지할 수 있는 최대 스레드 개수는 thread_cache_size 시스템 변수로 설정합니다. 
   
</details>

-----------------------

### 트랜잭션이란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+ 

</details>

-----------------------

### 인덱스의 장단점은?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+ 장점
    - 인덱스는 일종의 색인으로서, 매우 빠른 검색을 가능하게 한다는 점이 장점입니다. 

+ 단점
    - 인덱스는 데이터를 업데이트하거나 삭제할 때, 매번 정렬을 해줘야 하므로,
      업데이트 및 삭제의 성능은 떨어질 수 있다는 단점이 있습니다. 

</details>

-----------------------
### Hash Index 알고리즘의 장점과 단점은?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

-----------------------
+ 장점
    - Hash Index 알고리즘은 해시 값을 인덱싱하므로, 매우 빠른 검색을 지원합니다.  
+ 단점
    - 값을 변형하여 저장하므로, 전방(Prefix) 검색과 같은 것에 사용이 불가능합니다.
</details>

-----------------------

### 클러스터링 인덱스는?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+ 프라이머리 키 값이 비슷한 레코드끼리 묶어서 저장하는 것을 클러스터링 인덱스라고 표현합니다. <br>
  즉, 프라이머리 키 값에 의해 레코드의 저장 위치가 결정되며, 프라이머리 키 값이 변경된다면 <br>
  그 레코드의 물리적인 저장 위치도 바뀌어야 합니다. <br>
  클러스터링 인덱스는 테이블의 프라이머리 키에 대해서만 적용되는 내용이며, <br> 
  주로 비슷한 값들을 동시에 조회하는 경우가 많다는 점에 착안한 것입니다. <br>
</details>

-----------------------
### 정규화란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

-----------------------
+ 
</details>

-----------------------

### 실행 계획은?

<details>
   <summary> 답안 보기 (👈 Click)</summary> (작성중)
<br />

-----------------------
+ 
</details>

-----------------------
