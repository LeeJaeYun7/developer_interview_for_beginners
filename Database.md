# Database
<br>

-----------------------
### RDB vs NoSQL?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+ RDB
    - RDB는 테이블 형식의 고정된 스키마를 제공합니다. 
    - RDB는 테이블 간 Join문을 제공합니다.
    - RDB는 트랜잭션 기능을 제공합니다.
    - RDB는 엄격한 Schama로 데이터 중복이 없기 때문에 update가 많은 경우에 유리합니다. 
    - RDB는 Scale-up에 유리합니다. 

+ NoSQL
    - NoSQL은 다양한 형식으로 저장됩니다.(ex) Key-value, Graph-based, Column-based 등)
    - NoSQL은 일반적으로 Join문을 제공하지 않습니다. 
    - NoSQL은 일반적으로 트랜잭션 기능을 제공하지 않습니다. 
    - NoSQL은 빠른 읽기 성능을 가지고 있으므로, 일반적으로 많은 데이터를 읽는 서비스에 유리합니다. 
    - NoSQL은 Scale-out에 유리합니다. 

</details>

-----------------------

### MySQL 엔진은 무엇으로 구성되어 있나요?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+ MySQL 엔진은 클라이언트로부터의 접속 및 쿼리 요청을 처리하는 커넥션 핸들러, <br> 
  SQL 파서 및 전처리기,<br>
  쿼리의 최적화된 실행을 위한 옵티마이저가 중심을 이룹니다. 

</details>

-----------------------

### 스토리지 엔진의 기능은 무엇인가요?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+ 스토리지 엔진은 실제 데이터를 디스크 스토리지에 저장하거나, <br>
  디스크 스토리지로부터 데이터를 읽어오는 부분을 전담합니다. <br>
  MySQL 서버에서 MySQL 엔진은 하나지만, 스토리지 엔진은 여러 개를 동시에 사용할 수 있습니다. <br> 
  각 스토리지 엔진은 성능 향상을 위해 InnoDB 버퍼 풀(InnoDB 스토리지 엔진), 키 캐시(MyISAM 스토리지 엔진) <br>
  과 같은 기능을 내장하고 있습니다.  
   

</details>

-----------------------


### MySQL 스레딩 구조는 어떻습니까?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+ MySQL 서버는 프로세스 기반이 아니라 스레드 기반으로 동작하며, <br>
  크게 포그라운드(Foreground) 스레드와 백그라운드(Background) 스레드로 구분할 수 있습니다. <br>
  백그라운드 스레드의 개수는 MySQL 서버의 설정 내용에 따라 가변적일 수 있습니다. <br> 
  포그라운드 스레드는 최소한 MySQL 서버에 접속된 클라이언트의 수만큼 존재하며, <br>
  주로 각 클라이언트 사용자가 요청하는 쿼리 문장을 처리합니다. <br> 
   
</details>

-----------------------

### MySQL 스레드 캐시는 어떻게 동작합니까?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+ 클라이언트사용자가 작업을 마치고, 커넥션을 종료하면 해당 커넥션을 담당하던 스레드는<br>
  다시 스레드 캐시(Thread Cache)로 되돌아갑니다.<br>
  이 때, 이미 스레드 캐시에 일정 개수 이상의 대기 중인 스레드가 있으면, <br>
  스레드 캐시에 넣지 않고 스레드를 종료시켜 일정 개수의 스레드만 스레드 캐시에 존재하게 합니다.<br>
  이 때, 스레드 캐시에 유지할 수 있는 최대 스레드 개수는 thread_cache_size 시스템 변수로 설정합니다. 
   
</details>

-----------------------

### 트랜잭션이란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+ 

</details>

-----------------------

### 인덱스의 장단점은?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+ 장점
    - 인덱스는 일종의 색인으로서, 매우 빠른 검색을 가능하게 한다는 점이 장점입니다. 

+ 단점
    - 인덱스는 데이터를 업데이트하거나 삭제할 때, 매번 정렬을 해줘야 하므로,
      업데이트 및 삭제의 성능은 떨어질 수 있다는 단점이 있습니다. 

</details>

-----------------------
### Hash Index 알고리즘의 장점과 단점은?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

-----------------------
+ 장점
    - Hash Index 알고리즘은 해시 값을 인덱싱하므로, 매우 빠른 검색을 지원합니다.  
+ 단점
    - 값을 변형하여 저장하므로, 전방(Prefix) 검색과 같은 것에 사용이 불가능합니다.
</details>

-----------------------

### 클러스터링 인덱스는?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+ 프라이머리 키 값이 비슷한 레코드끼리 묶어서 저장하는 것을 클러스터링 인덱스라고 표현합니다. <br>
  즉, 프라이머리 키 값에 의해 레코드의 저장 위치가 결정되며, 프라이머리 키 값이 변경된다면 <br>
  그 레코드의 물리적인 저장 위치도 바뀌어야 합니다. <br>
  클러스터링 인덱스는 테이블의 프라이머리 키에 대해서만 적용되는 내용이며, <br> 
  주로 비슷한 값들을 동시에 조회하는 경우가 많다는 점에 착안한 것입니다. <br>
</details>

-----------------------
### 정규화란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+ 정규화란 하나의 릴레이션에 하나의 의미만 존재할 수 있도록 릴레이션을 분해해 나가는 과정을 의미합니다. <br> 
  반면, 비정규형은 하나의 튜플에서 속성을 입력되는 도메인 값으로 여러 개의 값이 들어와서, 원자성을 갖지 못하는 경우를 의미합니다. <br>
  제1 정규화란 원자값이 아닌 도메인을 분해하여 어떤 릴레이션 R에 속한 모든 도메인이 원자값으로만 설계하는 것을 의미합니다. <br> 
   
  제2 정규형은 어떤 릴레이션 R이 제1정규화에 속하고, 기본키에 속하지 않는 모든 속성이 기본키에 완전 함수적 종속이면 충족하는 정규화 <br> 
   
  제3 정규형은 어떤 릴레이션 R이 제2정규화에 속하고, 기본키에 속하지 않는 모든 속성이 기본키에 이행적 함수 종속이 아닌 상태의 관계 <br>  
</details>

-----------------------

### Connection pool이란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+ 애플리케이션의 스레드에서 데이터베이스에 접근하기 위해 Connection이 필요함 <br>
  데이터베이스와 Connection 객체들을 미리 생성해 Pool에 저장해 두었다가, 클라이언트의 요청이 들어올때마다 <br>
  사용/반환하는 방식을 의미합니다.
   
  Connection Pool의 데이터베이스 접근 과정은 다음과 같습니다. <br>
  (1) 웹 컨테이너가 실행되면 데이터베이스와 연결된 Connection 객체들을 미리 생성해 Pool에 저장 <br>
  (2) 클라이언트 요청 시 Pool에서 Connection 객체를 가져와 데이터베이스 접근 
  (3) 요청 처리가 끝나면 사용된 Connection 객체를 다시 Pool에 반환
   
  Connection Pool의 장점은 다음과 같습니다.
  (1) 매 연결마다 Connection 객체를 생성/제거하는 비용이 감소합니다. 
  (2) 미리 생성된 Connection 객체를 사용하믈모 데이터베이스 접근 시간을 단축합니다. 
  (3) Connection 수를 제한해 부하를 조정할 수 있습니다. 
   
  Connection Pool의 단점은 다음과 같습니다. 
  (1) Connection 또한 객체이므로 메모리를 차지합니다. 
  (2) Connection 개수를 잘못 설정할 경우, 쓸모없는 Connection이 발생할 수 있습니다. 
   
  Connection이 부족할 경우 
  (1) 모든 Connection이 요청을 처리 중일 때, 해당 클라이언트의 요청을 대기 상태로 전환합니다.
  (2) Pool에 Connection 객체가 반환되면 순차적으로 요청을 처리합니다.  
</details>

-----------------------

### 실행 계획은?

<details>
   <summary> 답안 보기 (👈 Click)</summary> (작성중)
<br />

+ 
</details>

-----------------------

### 샤딩이란?

<details>
   <summary> 답안 보기 (👈 Click)</summary> (작성중)
<br />

+ 
</details>

-----------------------
