# To the success
<br>


### 컴파일러 vs 인터프리터? (메쉬코리아)

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: 쉽게 배우는 운영체제] 
   
+ 컴파일러는 소스코드를 컴퓨터가 실행할 수 있는 기계어로 번역한 후 한꺼번에 실행합니다. <br> 
  C 언어, 자바 등이 이 방식으로 프로그램을 실행합니다. <br> 
  
  인터프리터는 소스코드를 한 행씩 번역하여 실행합니다. 자바스크립트, 베이직 등이 이 방식으로 프로그램을 실행합니다. <br> 
  
  컴파일러를 사용하는 목적은 <br>
  (1) 오류 발견 <br>
  - 컴파일러의 첫 번째 목적은 소스코드에서 오류를 발견하여 실행 시 문제가 없도록 하는 것입니다. <br> 
    컴파일러는 오류를 찾기 위해 심벌 테이블을 사용합니다. <br> 
    심벌 테이블은 변수 선언부에 명시한 각 변수의 이름과 종류를 모아놓은 테이블로, <br>
    선언하지 않은 변수를 사용하지는 않았는지, 변수에 다른 종류의 데이터를 저장하지는 않았는지 알 수 있습니다. <br> 
  
  (2) 코드 최적화 <br>
  - 컴파일러의 두 번째 목적은 최적화입니다. [그림 7-5]에는 '당근 1개를 잘라서 볶는다'가 두 번 나오는데 <br> 
    이를 '당근 2개를 잘라서 볶는다'로 변경하면 작업을 줄일 수 있습니다. <br> 
    또한, 준비 재료에는 들어 있지만 요리에 사용하지 않은 '고추'를 삭제하여 불필요한 재료를 없앨 수 있습니다. <br> 
    이러한 과정을 거치면 레시피가 최적화됩니다. 소스코드도 마찬가지로 군더더기와 사용하지 않는 변수를 삭제하면 <br> 
    더욱 간결해져서 실행 속도가 빨라집니다. <br> 
    결론적으로 컴파일러는 실행하기 전에 코드를 점검하여 오류를 수정하고 최적화함으로써 작고 빠른 실행 파일을 만듭니다. <br> 
  
  컴파일러를 사용하는 프로그래밍 언어는 사용할 변수를 먼저 선언한 후 코드를 작성합니다. <br> 
  이것이 다소 번거롭게 느껴질 수도 있으나 변수 선언은 오류를 찾고 코드를 최적화하기 위해 반드시 필요한 작업입니다. <br> 
  [그림 7-5]의 (b)에서 보듯이 준비 재료에 없는 재료를 사용하거나, 준비 재료에 명시되어 있으나 실제로 사용되지 않는 것을 골라내려면 <br> 
  준비 재료, 즉 변수가 미리 선언되어야 합니다. <br> 
  
  컴파일러는 실행 전에 소스코드를 점검하여 오류를 수정하고 필요 없는 부분을 정리하여 최적화된 실행 파일을 만듭니다. <br> 
  그러나 인터프리터는 한 줄씩 위에서부터 아래로 실행되기 때문에 같은 일을 반복하는 경우나 필요 없는 변수를 확인할 수는 없습니다. <br>
  따라서 크고 복잡한 프로그램에는 컴파일러를 사용하고, 간단한 프로그램에는 인터프리터를 사용합니다. <br> 
  
  컴파일러를 사용하는 자바와 인터프리터를 사용하는 자바스크립트를 비교해보면 컴파일러와 인터프리터의 차이를 알 수 있습니다. <br> 
  주로 대형 프로그램에 사용되는 자바는 컴파일 방식의 언어이므로, 변수를 미리 선언해야 합니다. <br> 
  컴파일 과정에서 최적화된 실행 파일이 만들어지며, 이 실행 파일을 실행하여 결과를 얻습니다. <br> 
  반면, 자바스크립트는 인터프리터 방식의 언어이므로 변수를 미리 선언할 필요가 없으며, 소스코드가 한 줄씩 실행됩니다. <br> 
  자바스크립트는 웹 프로그램 같은 간단한 프로그램을 작성하거나 데이터베이스를 다른 응용 프로그램과 연결하는 코드를 작성할 때 사용합니다. <br>  
  
</details>

-----------------------


### 인덱스란? 인덱스의 장단점은? (차이코퍼레이션)

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: Real MySQL p.218] 
   
+ 많은 사람이 인덱스를 언급할 때는 항상 책의 맨 끝에 있는 찾아보기로 설명합니다. <br> 
  책의 마지막에 있는 "찾아보기"가 인덱스에 비유된다면 책의 내용은 데이터 파일에 해당한다고 볼 수 있습니다. <br> 
  책의 찾아보기를 통해 알아낼 수 있는 페이지 번호는 데이터 파일에 저자아된 레코드의 주소에 비유될 것입니다. <br> 
   
  DBMS도 데이터베이스 테이블의 모든 데이터를 검색해서 원하는 결과를 가져오려면 시간이 오래 걸립니다. <br> 
  그래서 칼럼(또는 칼럼들)의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍(key-value pair)으로 삼아 <br>
  인덱스를 만들어 두는 것입니다. <br> 
   
  그리고 책의 "찾아보기"와 DBMS 인덱스의 공통점 가운데 중요한 것이 바로 정렬입니다. <br> 
  책의 찾아보기도 내용이 많아지면 우리가 원하는 검색어를 찾아내는데 시간이 걸릴 것입니다. <br> 
  그래서 최대한 빠르게 찾아갈 수 있게 "ㄱ", "ㄴ", "ㄷ"... 와 같은 순서로 정렬해 있는데, <br> 
  DBMS의 인덱스도 마찬가지로 칼럼의 값을 주어진 순서로 미리 정렬해서 보관합니다. <br> 
   
  인덱스의 또 다른 특성을 설명하고자 이번에는 프로그래밍 언어의 자료 구조로 인덱스와 데이터 파일을 비교해 가면서 살펴봅니다. <br> 
  프로그래밍 언어별로 각 자료 구조의 이름이 조금씩 다르긴 하지만, SortedList와 ArrayList라는 자료 구조는 익숙할 정도로 많이 들어봤을 것입니다. <br> 
  SortedList는 DBMS의 인덱스와 같은 자료 구조이며, ArrayList는 데이터 파일과 같은 자료 구조를 사용합니다. <br> 
   
  DBMS의 인덱스도 SortedList와 마찬가지로 저장되는 칼럼의 값을 이용해 항상 정렬된 상태를 유지합니다. <br> 
  데이터 파일은 ArrayList와 같이 저장된 순서대로 별도의 정렬 없이 그대로 저장해 둡니다. <br> 
   
  그러면 이제 SortedList의 장단점을 통해 인덱스의 장단점을 살펴봅니다. <br> 
  SortedList 자료 구조는 데이터가 저장될 때마다 항상 값을 정렬해야 하므로, 저장하는 과정이 복잡하고 느리지만, <br> 
  이미 정렬돼 있어서 아주 빨리 원하는 값을 찾아올 수 있습니다. <br> 
   
  DBMS의 인덱스도 인덱스가 많은 테이블은 당연히 INSERT나 UPDATE, DELETE 문장의 처리가 느려집니다. <br> 
  하지만 이미 정렬된 "찾아보기"용 표(인덱스)를 가지고 있기 때문에 SELECT 문장은 매우 빠르게 처리할 수 있습니다. <br> 
   
  결론적으로 DBMS에서 인덱스는 데이터의 저장(INSERT, UPDATE, DELETE) 성능을 희생하고, <br>
  그 대신 데이터의 읽기 속도를 높이는 기능입니다. <br> 
  여기서도 알 수 있듯이 테이블의 인덱스를 하나 더 추가할지 말지는 데이터의 저장 속도를 어디까지 희생할 수 있는지 <br> 
  읽기 속도를 얼마나 더 빠르게 만들어야 하느냐에 따라 결정해야 합니다. <br> 
  SELECT 쿼리 문장의 WHERE 조건절에 사용되는 칼럼이라고 해서 전부 인덱스로 생성하면 <br> 
  데이터 저장 성능이 떨어지고 인덱스의 크기가 비대해져 오히려 역효과만 불러올 수 있습니다. <br>
  
   
  
  
</details>

-----------------------


### 인덱스를 역할별로 구분해 본다면 어떠한가? (차이코퍼레이션)

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: Real MySQL p.219] 
   
+ 이 책에서는 키(Key)라는 말과 인덱스(Index)는 같은 의미로 사용합니다. <br> 
   
  인덱스를 역할별로 구분해 본다면 프라이머리 키(Primary Key)와 보조 키(세컨더리 인덱스, Secondary Index)로 구분할 수 있습니다. <br> 
   
  (1) 프라이머리 키는 이미 잘 아는 것처럼 그 레코드를 대표하는 칼럼의 값으로 만들어진 인덱스를 의미합니다. <br> 
      이 칼럼(때로는 칼럼의 조합)은 테이블에서 해당 레코드를 식별할 수 있는 기준값이 되기 때문에 우리는 이를 식별자라고도 부릅니다. <br> 
      프라이머리 키는 NULL 값을 허용하지 않으며, 중복을 허용하지 않는 것이 특징입니다. <br>
   
  (2) 프라이머리 키를 제외한 나머지 모든 인덱스는 세컨더리 인덱스(Secondary Index)로 분류합니다. 유니크 인덱스는 프라이머리 키와 성격이 비슷하고, <br> 
      프라이머리 키를 대체해서 사용할 수도 있다고 해서 대체 키라고도 하는데, <br>
      별도로 분류하기도 하고 그냥 세컨더리 인덱스로 분류하기도 합니다. <br> 
   
</details>

-----------------------


### 인덱스를 데이터 저장 방식(알고리즘)별로 구분할 경우 어떠한가? (차이코퍼레이션)

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: Real MySQL p.219] 
   
+ 데이터 저장 방식(알고리즘)별로 구분할 경우 사실 상당히 많은 분류가 가능하겠지만, <br>
  대표적으로 B-Tree 인덱스와 Hash 인덱스로 구분할 수 있습니다. br> 
  그리고 최근에는 Fractal-Tree 인덱스나 로그 기반의 Merge-Tree 인덱스와 같은 알고리즘을 사용하는 DBMS도 개발되고 있습니다. <br> 
  물론 이 외에도 수많은 알고리즘이 있지만 대표적으로 시중의 DBMS에서 많이 사용되는 알고리즘은 이 정도일 것입니다. <br> 
  
  (1) B-Tree 알고리즘은 가장 일반적으로 사용되는 인덱스 알고리즘으로서, <br> 
      상당히 오래전에 도입된 알고리즘이며 그만큼 성숙해진 상태입니다. <br> 
      B-Tree 인덱스는 칼럼의 값을 변형하지 않고, 원래의 값을 이용해 인덱싱하는 알고리즘입니다. <br> 
      MySQL 서버에서는 위치 기반 검색을 지원하기 위한 R-Tree 인덱스 알고리즘도 있지만, <br> 
      결국 R-Tree 인덱스는 B-Tree의 응용 알고리즘으로 볼 수 있습니다. <br> 
  
  (2) Hash 인덱스 알고리즘은 칼럼의 값으로 해시값을 계산해서 인덱싱하는 알고리즘으로 매우 빠른 검색을 지원합니다. <br> 
      하지만 값을 변형해서 인덱싱하므로 전방(Prefix)일치와 같이 값의 일부만 검색하거나 범위를 검색할 때는 <br> 
      해시 인덱스를 사용할 수 없습니다. <br>
      Hash 인덱스는 주로 메모리 기반의 데이터베이스에서 많이 사용합니다. <br> 
   
</details>

-----------------------


### B-Tree 인덱스란? (차이코퍼레이션)

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: Real MySQL p.220] 
   
+ B-Tree는 데이터베이스의 인덱싱 알고리즘 가운데 가장 일반적으로 사용되고, 가장 먼저 도입된 알고리즘입니다. <br>
  하지만 아직도 가장 범용적인 목적으로 사용되는 인덱스 알고리즘입니다. <br>
  B-Tree에는 여러 가지 변형된 형태의 알고리즘이 있는데, 일반적으로 DBMS에서는 주로 B+ Tree 또는 B*-Tree가 사용됩니다.<br>
  인터넷상에서 쉽게 구할 수 있는 B-Tree의 구조를 설명한 그림 때문인지 많은 사람들이 B-Tree의 “B”가 바이너리(이진) 트리라고 잘못 생각합니다. <br>  
 
  하지만 B-Tree의 B는 Binary의 약자가 아니라 Balanced를 의미한다는 점에 주의합니다. <br>  
  B-Tree는 칼럼의 원래 값을 변형시키지 않고 인덱스 구조체 내에서는 항상 정렬되니 상태로 유지합니다. <br>
  전문 검색과 같은 특수한 요건이 아닌 경우, 대부분 인덱스는 거의 B-Tree를 사용할 정도로 일반적인 용도에 적합한 알고리즘입니다. <br> 

</details>

-----------------------

### Balanced Tree란? (차이코퍼레이션)

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: ] 
   
+ 

</details>

-----------------------



### 가상 메모리란? (헤이비트)

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: 쉽게 배우는 운영체제 p.378] 
   
+ 가상 메모리는 물리 메모리(실제 메모리)의 크기와 상관없이 메모리를 이용할 수 있도록 지원하는 기술입니다. <br> 
  프로그래머는 가상 메모리 덕분에 물리 메모리의 크기에 구애받지 않고 작업할 수 있는 커다란 작업 공간을 얻게 되는 셈입니다. <br> 
  이 장에서는 가상 메모리 시스템을 운영하는 메모리 관리자의 역할과 다양한 관리 기법을 살펴봅니다. <br> 
   
  컴퓨터마다 물리 메모리, 즉 실제 메모리의 크기가 다르다. <br>
  가상 메모리는 크기가 다른 물리 메모리에서 일관되게 프로세스를 실행할 수 있는 기술이다. <br> 
  이 절에서는 가상 메모리가 무엇인지, 그리고 어떻게 구현하는지를 살펴봅니다. <br> 
   
  메모리의 크기는 컴퓨터마다 다른데 운영체제가 물리 메모리의 크기에만 의존한다면 2GB의 메모리에서 동작하는 프로그램이 <br> 
  1GB의 메모리에서는 동작하지 않을 수 있습니다. <br> 
  프로그래머 또한 메모리 크기에 맞는 응용 프로그램만 개발해야 하는데, 실제로 메모리 크기만 고려하여 프로그래밍하기란 매우 어렵습니다. <br> 
  사용할 수 있는 배열의 개수가 한정되거나, 특정 변수에 접근할 수 없다는 제약은 프로그래머에게 큰 장벽입니다. <br>
   
  현대 메모리 관리의 가장 큰 특징은 물리 메모리의 크기와 프로세스가 올라갈 메모리의 위치를 신경쓰지 않고, 프로그래밍하도록 지원한다는 것입니다. <br> 
  이러한 메모리 시스템을 가상 메모리라고 부릅니다. <br> 
  가상 메모리는 물리 메모리의 크기와 상관없이 프로세스에 커다란 메모리 공간을 제공하는 기술입니다. <br> 
  프로세스는 운영체제가 어디에 있는지, 물리 메모리의 크기가 어느 정도인지 신경 쓰지 않고 메모리를 마음대로 사용할 수 있습니다. <br> 
   
  가상 메모리 시스템의 모든 프로세스는 물리 메모리와 별개로 자신이 메모리의 어느 위치에 있는지 상관없이 0번지부터 시작하는 연속된 메모리 공간을 가집니다. <br> 
  이는 7장에서 소개한 논리 주소와 유사하지만 한 가지 차이점이 있습니다. <br> 
  논리 주소는 물리 메모리의 주소 공간에 비례하고, 가상 주소는 물리 메모리 공간이 아닌 가상의 주소 공간을 가진다는 것입니다. <br> 
   
  [그림 8-2]는 가상 메모리의 구성을 나타낸 것입니다. 가상 메모리는 크게 프로세스가 바라보는 메모리 영역과 메모리 관리자가 바라보는 메모리 영역으로 나뉩니다. <br>
  
  이론적으로 가상 메모리는 무한대의 크기입니다. 그러나 실제로 가상 메모리의 최대 크기는 그 컴퓨터 시스템이 가진 물리 메모리의 최대 크기로 한정되며, <br> 
  7장에서 설명했듯이, CPU의 비트에 따라 결정됩니다. <br> 
  32bit CPU의 경우 32bit로 표현할 수 있는 최대값인 2^32-1(16진수로 FFFFFFFF), 즉, 약 4GB가 메모리의 최대 크기이고, 가상 메모리의 최대 크기도 약 4GB입니다. <br> 
   
  그런데 가상 메모리는 실제로 사용할 수 있는 최대 크기의 제약에도 불구하고, 어떻게 이론적으로 무한대의 크기가 있는 것처럼 구현할 수 있을까? <br> 
  예를 통해 살펴보자. <br> 
   
  32bit CPU의 최대 메모리 크기는 4GB입니다. 이 시스템에서 각각 4GB 주소 공간을 차지하는 10개의 프로세스를 동시에 실행하려면, <br>
  운영체제를 포함하여 적어도 40GB의 메모리가 필요합니다. <br> 
  이 경우 가상 메모리 시스템에서는 물리 메모리의 내용 중 일부를 하드디스크의 일부 공간, 즉 스왑 영역으로 옮깁니다. <br> 
  스왑 영역은 하드디스크에 존재하지만, 메모리 관리자가 관리하는 영역으로서 메모리의 일부이며, 가상 메모리의 구성 요소 중 하나입니다 <br> 
   
  메모리 관리자는 물리 메모리의 부족한 부분을 스왑 영역으로 보충합니다. <br> 
  즉, 물리 메모리가 꽉 찼을 때, 일부 프로세스를 스왑 영역으로 보내고(스왑 아웃), <br>
  몇 개의 프로세스가 작업을 마치면 스왑 영역에 있는 프로세스를 메모리로 가져옵니다. (스왑 인) <br> 
   
  가상 메모리의 크기 - 가상 메모리에서 메모리 관리자가 사용할 수 있는 메모리의 전체 크기는 물리 메모리(실제 메모리)와 <br>
  스왑 영역을 합한 크기입니다. <br> 
   
  가상 메모리 시스템에서 메모리 관리자는 물리 메모리와 스왑 영역을 합쳐서 프로세스가 사용하는 가상 주소를 실제 메모리의 물리 주소로 변환하는데, <br> 
  이러한 작업을 동적 주소 변환이라고 합니다. <br> 
  동적 주소 변환을 거치면 프로세스가 아무 제약 없이 사용자의 데이터를 물리 메모리에 배치할 수 있습니다. <br> 
  이 과정에서 메모리 관리자는 물리 메모리를 어떤 방법으로 나눌지, 사용자 프로세스를 어디에 배치할지, <br>
  부족한 물리 메모리를 어떻게 처리할지 등의 복잡한 문제를 처리합니다. <br> 
   
</details>

-----------------------


### Round Robin 스케줄링이란? (위메프)

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: 쉽게 배우는 운영체제 p.220] 
   
+ '순환 순서 방식'으로 번역되는 라운드 로빈 스케줄링은 한 프로세스가 할당받은 시간(타임 슬라이스)동안 작업을 하다가 <br> 
   작업을 완료하지 못하면 준비 큐의 맨 뒤로 가서 자기 차례를 기다리는 방식입니다. <br> 
   선점형 알고리즘 중 가장 단순하고 대표적인 방식으로, 프로세스들이 작업을 완료할 때까지 계속 순환하면서 실행됩니다. <br> 
   
   라운드 로빈 스케줄링은 FCFS 스케줄링과 유사한데, 차이점은 각 프로세스마다 CPU를 사용할 수 있는 최대 시간, <br>
   즉, 타임 슬라이스가 있다는 것입니다. <br> 
   프로세스는 자신에게 주어진 타임 슬라이스 동안만 작업할 수 있으며, 작업이 다 끝나지 않으면 큐의 뒤쪽에 다시 삽입됩니다. <br> 
   라운드 로빈 스케줄링은 우선순위가 적용되지 않은 가장 단순한 선점형 스케줄링 방식입니다. <br> 
   
</details>

-----------------------


### 선점형 스케줄링 방식이란 무엇인가? (위메프)

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: 쉽게 배우는 운영체제 p.212] 
   
+ 스케줄링 알고리즘은 크게 비선점형 알고리즘과 선점형 알고리즘으로 나뉩니다. <br> 
  비선점형 알고리즘은 프로세스가 CPU를 할당받으면 작업이 끝날 때까지 CPU를 놓지 않기 때문에, <br>
  효율이 떨어져서 지금은 거의 사용되지 않습니다. <br> 
  
  선점형 알고리즘은 시분할 시스템을 고려하여 만들어진 알고리즘으로, 어떤 프로세스가 CPU를 할당 받아 실행 중이라도 <br>
  운영체제가 CPU를 강제로 빼앗을 수 있습니다. <br> 
</details>

-----------------------

### Round Robin 스케줄링의 성능은 어떠한가? (위메프)

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: 쉽게 배우는 운영체제 p.221] 
   
+ 타임 슬라이스가 10밀리초인 시스템에서 앞의 [표 4-3]과 같은 프로세스가 실행될 때, 라운드 로빈 스케줄링의 평균 대기 시간을 계산해봅니다. <br> 
  프로세스 P1은 도착하자마자 실행되므로, 대기 시간이 0밀리초입니다. <br> 
  P1은 자신에게 주어진 작업 시간인 10밀리초 동안 실행된 후 큐의 맨 뒤로 이동합니다. <br> 
  프로세스 P2는 3밀리초 후에 도착하여 7밀리초를 기다렸다 10밀리초 동안 실행되고 나서 큐의 맨 뒤로 이동합니다. <br> 
  프로세스 P3은 6밀리초 후에 도착하여 14밀리초를 기다렸다 9밀리초 동안 실행되어 작업을 마칩니다. <br> 
   
  프로세스 P1은 29밀리초 후에 작업을 다시 시작합니다. 앞에서 10밀리초 동안 실행되었기 때문에, <br>
  실제 대기 시간은 19밀리초입니다. 프로세스 P1이 10밀리초 동안 실행된 후 큐의 맨 뒤로 이동하면 <br> 
  P2가 8밀리초 동안 실행되어 남은 작업을 마치며, 마지막으로 P1이 10밀리초 동안 실행되어 작업을 마칩니다. <br> 
   
  이 세 프로세스의 총 대기 시간은 0(P1)+7(P2)+14(P3)+19(P1)+19(P2)+8(P1) = 67밀리초이고, 평균 대기 시간은 67 / 3 = 22.33밀리초입니다. <br> 
  라운드 로빈 스케줄링 같은 선점형 방식에서는 프로세스가 CPU를 일정 시간 동안 사용한 후 다른 프로세스에 주어야 하기 때문에 <br>
  앞의 긴 작업을 무작정 기다리는 콘베이 효과가 줄어듭니다. <br> 
   
</details>

-----------------------

### 클러스터링 인덱스란? (메쉬코리아)

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: Real MySQL p.270] 
   
+ 클러스터링이란 여러 개를 하나로 묶는다는 의미로 주로 사용되는데, 지금 설명하고자 하는 인덱스의 클러스터링도 그 의미를 크게 벗어나지 않는다. <br> 
  MySQL 서버에서 클러스터링은 테이블의 레코드를 비슷한 것(프라이머리 키를 기준으로)들끼리 묶어서 저장하는 형태로 구현되는데, <br> 
  이는 주로 비슷한 값들을 동시에 조회하는 경우가 많다는 점에 착안한 것이다. <br> 
   
  MySQL에서 클러스터링 인덱스는 InnoDB 스토리지 엔진에서만 지원하며, 나머지 스토리지 엔진에서는 지원되지 않는다. <br> 
  
  클러스터링 인덱스는 테이블의 프라이머리 키에 대해서만 적용되는 내용이다. 즉, 프라이머리 키 값이 비슷한 레코드끼리 묶어서 저장하는 것을 <br>
  클러스터링 인덱스라고 표현한다. <br> 
  여기서 중요한 것은 프라이머리 키 값에 의해 레코드의 저장 위치가 결정된다는 것이다. <br> 
  또한, 프라이머리 키 값이 변경된다면 그 레코드의 물리적인 저장 위치가 바뀌어야 한다는 것을 의미하기도 한다. <br> 
  프라이머리 키 값으로 클러스터링된 테이블은 프라이머리 키 값에 대한 의존도가 상당히 크기 때문에, <br> 
  신중히 프라이머리 키를 결정해야 한다. <br> 
   
  클러스터링 인덱스는 프라이머리 키 값에 의해 레코드의 저장 위치가 결정되므로, <br> 
  사실 인덱스 알고리즘이라기보다 테이블 레코드의 저장 방식이라고 볼 수 있다. <br> 
  그래서 클러스터링 인덱스와 클러스터링 테이블은 동의어로 사용됟기도 한다. <br> 
  또한 클러스터링의 기준이 되는 프라이머리 키는 클러스터링 키라고도 표현한다. <br> 
  일반적으로 InnoDB와 같이 항상 클러스터링 인덱스로 저장되는 테이블은 프라이머리 키 기반의 검색이 매우 빠르며, <br> 
  대신 레코드의 저장이나 프라이머리 키의 변경이 상대적으로 느리다. <br> 
   
</details>

-----------------------

### 옵저버 패턴이란? (메쉬코리아)


<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: 헤드 퍼스트 디자인 패턴] 
   
+ 옵저버 패턴은 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체에게 연락이 가고 <br>
  자동으로 내용이 갱신되는 방식으로 일대다(one-to-many) 의존성을 정의합니다. <br>
  주제와 옵저버로 일대다 관계가 정의되고, 옵저버는 주제에 딸려 있으며, <br> 
  주제의 상태가 바뀌면 옵저버에게 정보가 전달됩니다. <br>
   
  옵저버 패턴은 여러 가지 방법으로 구현할 수 있지만, 보통은 주제 인터페이스와 옵저버 인터페이스가 들어 있는 <br>
  클래스 디자인으로 구현합니다. 
   
   
[참고: GoF의 디자인 패턴] 
   
+ 객체 사이에 일대다의 의존관계를 정의해 두어, 어떤 객체의 상태가 변할 때 그 객체에 의존성을 가진 <br> 
  다른 객체들이 그 변화를 통지 받고 자동으로 갱신될 수 있게 만듭니다. <br> 
  다른 이름으로 종속자(Dependent), 게시-구독(Publish-Subscribe)이라고도 합니다. <br> 
  
  어떤 하나의 시스템을 서로 연동되는 클래스 집합으로 분할했을 때, <br>
  발생하는 공통적인 부작용은 관련된 객체 간에 일관성을 유지하도록 해야 한다는 것입니다. <br> 
  그렇다고 이 일관성 관리를 위해서 객체 간의 결합도를 높이고 싶지는 않습니다. <br> 
  그렇게 되면 각 클래스의 재사용성이 떨어지기 때문입니다. <br> 
  
  예를 들어, 많은 그래픽 사용자 인터페이스 툴킷은 표현 부분과 이에 대응하는 데이터를 분리합니다. <br> 
  응용 프로그램 자료와 표현을 정의하는 클래스는 독립적으로 재사용할 수 있습니다. <br> 
  그러나 이들은 함께 동작해야 합니다. <br> 
  예를 들어, 테이블 형태의 객체와 바 형태로 표현된 객체 모두 하나의 동일한 자료 값을 나타내나, <br>
  스프레드 시트와 바는 서로 관련 없는 클래스들이므로 독립적으로 재사용이 가능해야 합니다. <br> 
  만약, 이 독립적 객체가 하나의 정보 값을 표현하는데 함께 사용된다면, <br>
  사용자가 스프레드시트에서 정보를 변경할 때 바에도 이 변경된 정보가 반영되어야 합니다. <br> 
   
  스프레드시트와 바 차트는 데이터 객체에 종속적이기 때문에 그 데이터에 일어난 변경을 통보받아야 합니다. <br> 
  그러나 반드시 이 예처럼 종속적인 객체의 개수가 두 개로 제한되는 것은 아닙니다. <br>
  서로 다른 다수의 사용자 인터페이스가 하나의 데이터에 종속될 수 있습니다. <br> 
   
  감시자 패턴은 이런 관련성을 관리하는 패턴입니다. <br> 
  이 패턴에서 중요한 객체는 주체(subject)와 감시자(observer)입니다. <br> 
  주체는 독립된 여러 개의 감시가 있을 수 있습니다. <br>
  모든 감시자는 주체의 상태 변화가 있을 때마다, 이 변화를 통보 받습니다. <br>
  각 감시자는 주체의 상태와 자신의 상태를 동기화시키기 위해 주체의 상태를 알아봅니다. <br> 
  
  이런 종류의 상호 작용을 게시-구독 관계라고 합니다. <br>
  주체는 상태 변경에 대한 통보를 하는 것이므로, 누가 감시자인지 모른 채 통보를 발송합니다. <br>
  불특정 다수의 감시자가 이 통보를 수신하기 위해서 구독을 신청하는 것입니다. 
   
</details>

-----------------------

### 데드락이란? (헤이비트)

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
   
</details>

-----------------------

### Node.js의 이벤트 루프란? (블랭크랩)

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
   
</details>

-----------------------

### Node.js의 싱글 스레드는 어떻게 동작하는가? (헤이비트)

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
   
</details>

-----------------------

### JPA의 N+1 문제란? (블랭크랩)

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
   
</details>

-----------------------

### 동기 vs 비동기? (이스트소프트/모의 면접)

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
   
</details>

-----------------------

### HTTP vs HTTPS? (자란다)
<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: HTTP 완벽 가이드 p.355~p.356] 
   
+ 이전 3개 장에서 사용자를 식별하고 인증하는 것을 도와주는 HTTP의 기능들에 대해 살펴보았습니다. <br>
  이 기법들은 우호적인 관계가 형성되어 있는 커뮤니티에서는 잘 동작하지만, <br>
  적대행위가 일어날 가능성이 있는 커뮤니티에서 중요한 트랜잭션을 보호하기에는 부족합니다. <br> 
  
  이 장에서는 디지털 암호화를 이용해 도청이나 위조로부터 HTTP 트랜잭션을 안전하게 보호하는 <br>
  더 복잡하고 적극적인 기술을 제시합니다. <br> 
   
  사람들은 웹 트랜잭션을 중요한 일에 사용합니다. <br> 
  강력한 보안이 없다면, 사람들은 온라인 쇼핑이나 인터넷 뱅킹을 할 때, 안심할 수 없을 것입니다. <br> 
  제한된 접근이 가능하지 않다면, 회사들은 중요한 문서를 웹 서버에 올려놓을 수 없을 것입니다. <br> 
  웹은 안전한 방식의 HTTP를 필요로 합니다. 
   
  이전 장에서 인증(기본 그리고 다이제스트 인증)과 메시지 무결성(요약) <br> 
  을 제공하는 가벼운 방법에 대해 이야기했습니다. <br> 
  이들은 대체로 쓸만하지만, 대량 구매, 은행 업무, 혹은 보안 자료 접근을 위해서는 충분히 강력하지 않습니다. <br>
  보다 중요한 트랜잭션을 위해서는, HTTP와 디지털 암호화 기술을 결합해야 합니다. 
   
  HTTP의 보안 버전은 효율적이고, 이식성이 좋아야 하고, 관리가 쉬워야 하며, 현실 세계의 변화에 대한 적응력이 좋아야 합니다. <br> 
  또한, 사회와 정부의 요구사항에도 맞아야 합니다. <br> 
  우리는 다음을 제공해 줄 수 있는 HTTP 보안 기술이 필요합니다. <br> 
   
  (1) 서버 인증 - 클라이언트는 자신이 위조된 서버가 아닌 진짜와 이야기하고 있음을 알 수 있어야 합니다. <br> 
  (2) 클라이언트 인증 - 서버는 자신이 가짜가 아닌 진짜 사용자와 이야기하고 있음을 알 수 있어야 합니다. <br> 
  (3) 무결성 - 클라이언트와 서버는 그들의 데이터가 위조되는 것으로부터 안전해야 합니다. <br> 
  (4) 암호화 - 클라이언트와 서버는 도청에 대한 걱정 없이 서로 대화할 수 있어야 합니다. <br> 
  (5) 효율 - 저렴한 클라이언트나 서버도 이용할 수 있도록 알고리즘은 충분히 빨라야 합니다. <br> 
  (6) 편재성(Ubiquity) - 프로토콜은 거의 모든 클라이언트와 서버에서 지원되어야 합니다. <br> 
  (7) 관리상 확장성 - 누구든 어디서든 즉각적인 보안 통신을 할 수 있어야 합니다. <br> 
  (8) 적응성 - 현재 알려진 최선의 보안 방법을 지원해야 합니다. <br> 
  (9) 사회적 생존성 - 사회의 문화적 정치적 요구를 만족시켜야 합니다. <br>  
</details>

-----------------------


### HTTPS란? (자란다)
<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: HTTP 완벽 가이드 p.356] 
   
+ HTTPS는 HTTP를 안전하게 만드는 방식 중에서 가장 인기 있는 것입니다. <br> 
  넷스케이프 커뮤니케이션 주식회사에서 개척하였으며, 모든 주류 브라우저와 서버에서 지원합니다. <br> 
  
  웹페이지에 HTTP가 아닌 HTTPS로 접근하고 있는 경우, URL이 http:// 대신 https://로 시작하는 것을 보고 그 사실을 알아챌 수 있습니다. <br> 
  HTTPS를 사용할 때, 모든 HTTP 요청과 응답 데이터는 네트워크로 보내기 전에 암호화됩니다. <br> 
  HTTPS는 HTTP의 하부에 전송 레벨 암호 보안 계층을 제공함으로써 동작하는데, <br>
  
  이 보안 계층은 안전 소켓 계층(SSL) 혹은 그를 계승한 전송 계층 보안(TLS)을 이용하여 구현됩니다. <br> 
  SSL과 TLS는 매우 비슷하기 때문에, 이 책에서는 SSL과 TLS 양쪽 모두를 표현하는 용어로 엄밀하지는 않지만, <br>
  'SSL'이라는 단어를 사용합니다. <br> 
   
  어려운 인코딩 및 디코딩 작업은 대부분 SSL 라이브러리 안에서 일어나기 때문에, <br>
  보안 HTTP를 사용하기 위해 웹 클라이언트와 서버가 프로토콜을 처리하는 로직을 크게 변경할 필요는 없습니다. <br> 
  대부분의 경우, TCP 입력/출력 호출을 SSL 호출로 대체하고, 보안 정보를 설정하고 관리하기 위한 몇 가지 호출을 추가하기만 하면 됩니다. <br> 
   
</details>

-----------------------


### SSL이란? (자란다)
<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: HTTP 완벽 가이드 p.356] 
   
+ 
   
</details>

-----------------------

### 선언형 프로그래밍 vs 명령형 프로그래밍? (블랭크랩)

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
   
</details>

-----------------------

### 객체지향을 자신만의 언어로 설명하라 (뮤즈라이브)

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
   
</details>

-----------------------

### 프로젝트 시, 아키텍쳐 설계를 어떻게 했는가? (이스트소프트)

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
   
</details>

-----------------------

### 아키텍처 설계를 어떻게 했는가? (헤이비트)

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
   
</details>

-----------------------

### DNS란? (자란다)

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: https://hanamon.kr/dns%EB%9E%80-%EB%8F%84%EB%A9%94%EC%9D%B8-%EB%84%A4%EC%9E%84-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EA%B0%9C%EB%85%90%EB%B6%80%ED%84%B0-%EC%9E%91%EB%8F%99-%EB%B0%A9%EC%8B%9D%EA%B9%8C%EC%A7%80/]    
   
+ DNS는 사람이 읽을 수 있는 도메인 이름(ex)www.hanamon.co.kr)을 IP주소로 변환하는 시스템입니다. <br> 
  이번 글에서는 도메인 주소를 IP 주소로 변환할 수 있게 하는 인프라가 어떻게 구성 되어 있고, 실제로 어떤 기계들이 어떤 과정으로 동작하는지 알아보겠습니다.<br> 
  중요한 것은 왜 이러한 전세계적인 시스템을 인간들이 만들어냈는지, 그 많은 도메인 이름을 도대체 어디에 저장되어 있는 것인지, <br>
  어떻게 효과적으로 찾는 것인지, 빠르게 찾아내는 것인지 등을 중점으로 살펴보면 좋을 것 같습니다. <br> 
  그리고 이러한 시스템의 한계는 없을지, 개선점은 없을지, 좋은 아이디어 같은지 등도 같이 생각해보면 좋을 것 같습니다. <br> 
   
  DNS란? <br> 
  - 웹사이트에 접속할 때, 우리는 외우기 어려운 IP 주소 대신 도메인 이름을 사용합니다. <br> 
    도메인 이름을 사용했을 때, 입력한 도메인을 실제 네트워크상에서 사용하는 IP 주소로 바꾸고, <br> 
    해당 IP 주소로 접속하는 과정이 필요합니다. <br> 
    이러한 과정, 전체 시스템을 DNS(도메인 네임 시스템)라고 합니다. <br> 
    이러한 시스템은 전세계적으로 약속된 규칙을 공유합니다. <br> 
    상위 기관에서 인증된 기관에게 도메인을 생성하거나, IP 주소로 변경할 수 있는 '권한'을 부여합니다. <br> 
    DNS는 이처럼 상위 기관과 하위 기관과 같은 '계층 구조'를 가지는 분산 데이터베이스 구조를 가집니다. <br> 
</details>

-----------------------

### DNS의 구성요소는 무엇입니까? (자란다)

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: https://hanamon.kr/dns%EB%9E%80-%EB%8F%84%EB%A9%94%EC%9D%B8-%EB%84%A4%EC%9E%84-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EA%B0%9C%EB%85%90%EB%B6%80%ED%84%B0-%EC%9E%91%EB%8F%99-%EB%B0%A9%EC%8B%9D%EA%B9%8C%EC%A7%80/]    
   
+ DNS는 아래 세 가지 요소로 구성됩니다. <br> 
  1. 도메인 네임 스페이스(Domain Name Space) <br>
  2. 네임 서버 - 권한 있는 DNS 서버 <br> 
  3. 리졸버 - 권한 없는 DNS 서버 <br> 
   
  - 우선 "이 도메인 이름은 이 IP 주소이다"라는 '텍스트"를 저장하는 데이터베이스가 필요합니다. <br> 
  - 그리고 분산된 데이터가 어디 저장되어 있는지 찾을 프로그램들이 필요하고, 찾았으면 해당 IP 주소로 이동할 프로그램(브라우저 등)이 필요합니다. <br> 
  - 도메인 네임 스페이스라는 규칙(방법)으로 도메인 이름 저장을 분산합니다. <br> 
  - 네임 서버(=DNS 서버)가 해당 도메인 이름의 IP 주소를 찾습니다. <br> 
  - 리졸버가 DNS 클라이언트 요청을 네임 서버로 전달하고 찾으느 정보를 클라이언트에게 제공하는 기능을 수행합니다. <br> 
  - 어떤 네임 서버에서 찾아야하는지, 이미 캐시 되어 있는지 등 어떻게든 찾아서 클라이언트에게 찾았으면 찾은 것을, <br> 
    못 찾았으면 못 찾았다고 전달하는 역할을 합니다. <br> 
  - 리졸버는 단말에 구현하는 것은 무리수라 보통은 리졸버가 구현된 네임 서버의 IP 주소만을 파악합니다. <br> 
    대표적인 것이 KT/LG/SK와 같은 ISP(통신사) DNS가 있고, 브라우저 우회 용도로 많이 쓰는 구글 DNS, 클라우드 플레어와 같은 <br> 
    Public DNS 서버가 있습니다. <br> 
  - 그래서 거의 Resolver = Resursive DNS Server = Local Server(of ISP) = Recursor 입니다. <br> 
</details>

-----------------------

### DNS의 동작 방식은 어떠합니까? (자란다)

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: https://hanamon.kr/dns%EB%9E%80-%EB%8F%84%EB%A9%94%EC%9D%B8-%EB%84%A4%EC%9E%84-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EA%B0%9C%EB%85%90%EB%B6%80%ED%84%B0-%EC%9E%91%EB%8F%99-%EB%B0%A9%EC%8B%9D%EA%B9%8C%EC%A7%80/]    
   
+ (1) 웹 브라우저는 resolver에게 요청합니다. (ex) www.hanamon.kr의 IP 주소를 알려주세요"); <br>
  (2) Resolver는 최상위 기관에서 관리하는 네임 서버에게 요청합니다. (ex) ".kr이라는 도메인이 있나요?"); <br> 
  (3) 최상위 기관에서 관리하는 네임 서버는 응답합니다. (ex) ".kr은 한국 국가 도메인입니다. .kr 네임 서버로 가보세요~"); 
  (4) Resolver는 이제는 .kr 네임 서버에게 요청합니다. (ex) "hanamon.kr 있나요?") <br> 
  (5) .kr 네임 서버는 응답합니다. (ex) 네. 가비아로 가세요~"); <br>
  (6) Resolver는 가비아 네임 서버에게 요청합니다. (ex) www.hanamon.kr 있나요?") <br>
  (7) 가비아 네임 서버는 응답합니다. (ex) 네. 12.345.678.900으로 가세요!") <br> 
  (8) Resolver는 웹 브라우저에게 알려줍니다. (ex) 네. 1.345.678.900으로 가세요!"); 
</details>

-----------------------

### 도메인 네임 스페이스(Domain Name Space)란 무엇인가? (자란다)

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: https://hanamon.kr/dns%EB%9E%80-%EB%8F%84%EB%A9%94%EC%9D%B8-%EB%84%A4%EC%9E%84-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EA%B0%9C%EB%85%90%EB%B6%80%ED%84%B0-%EC%9E%91%EB%8F%99-%EB%B0%A9%EC%8B%9D%EA%B9%8C%EC%A7%80/]    
   
+ DNS는 전세계적인 거대한 분산 시스템입니다. <br> 
  도메인 네임 스페이스는 이러한 DNS가 저장 관리하는 계층적 구조를 의미합니다. <br> 
  도메인 네임 스페이스는 최상위 루트 DNS 서버가 존재하고, 그 하위로 연결된 모든 노드가 연속해서 이어진 계층 구조로 되어 있습니다. (폴더 구조와 비슷합니다.) <br>
   
</details>

-----------------------

### 계층적 도메인 레벨이란 무엇입니까? (자란다)

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: https://hanamon.kr/dns%EB%9E%80-%EB%8F%84%EB%A9%94%EC%9D%B8-%EB%84%A4%EC%9E%84-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EA%B0%9C%EB%85%90%EB%B6%80%ED%84%B0-%EC%9E%91%EB%8F%99-%EB%B0%A9%EC%8B%9D%EA%B9%8C%EC%A7%80/]    
   
+ 도메인 네임 스페이스의 트리 구조는 최상위 레벨부터 순차적으로 계층적 소속 관계를 나타냅니다. <br> 
  하위 조직의 네임 스페이스를 할당하고 관리하는 방식은 각 하위 기관의 관리 책임자에게 위임됩니다. <br> 
  예를 들어, hanamon.kr 도메인은 kr 도메인을 관리하는 네임 서버에 등록되어 있고, <br> 
  www.hanamon.kr은 hanamon.kr을 관리하는 네임 서버에 등록되어 있습니다. <br> 
  
  blog.hanamon.kr을 생성하기 위해서는 hanamon.kr 도메인을 관리하는 네임 서버의 레코드만을 수정함으로써 가능합니다. <br> 
  이러한 위임 구조는 호스트의 증가에 따른 관리가 효율적으로 이루어지는 것을 가능하게 합니다. <br> 
  hanamon.kr은 kr 도메인을 관리하는 네임 서버에 등록되어 있는데, 해당 하위 기관은 가비아로 되어 있습니다. <br> 
  하나몬은 www.hanamon.kr을 만들기 위해서 가비아에 가서 도메인 레코드에 하위 도메인을 추가하면 됩니다. (가비아가 하위 기관입니다.) <br> 
  
  그래서 AWS 같은 호스팅에서 가비아에서 구매한 도메인을 사용하려 한다면, route53에 생성된 네임 서버를 가비아 도메인에 추가해야 합니다. <br> 
  해당 도메인에 대한 IP 주소를 route53 네임 서버에서 찾으시오. 같은 것입니다. <br>
  Route53에서는 해당 인스턴스나 버킷 등으로 연결되어 있습니다. <br> 
   
  또는 카페24 같은 호스팅에서 가비아에서 구매한 도메인을 사용하려 한다면, 카페24의 네임 서버를 가비아 도메인에 추가해야 합니다. <br> 
  해당 도메인에 대한 IP 주소를 카페 24 네임 서버에서 찾으시오 같은 것입니다. <br> 
  그리고 카페 24에도 해당 도메인을 연결합니다. <br> 
  카페24에 추가가 가능하군요. 추가하겠음. 그리고 사용중인 호스팅에 연ㅇ결하세요. 하면 끝납니다. <br> 
   
</details>

-----------------------


### 네임 서버란? (자란다)

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: https://hanamon.kr/dns%EB%9E%80-%EB%8F%84%EB%A9%94%EC%9D%B8-%EB%84%A4%EC%9E%84-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EA%B0%9C%EB%85%90%EB%B6%80%ED%84%B0-%EC%9E%91%EB%8F%99-%EB%B0%A9%EC%8B%9D%EA%B9%8C%EC%A7%80/]    
   
+ 
   
</details>

-----------------------

### 리졸버란? (자란다)

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: https://hanamon.kr/dns%EB%9E%80-%EB%8F%84%EB%A9%94%EC%9D%B8-%EB%84%A4%EC%9E%84-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EA%B0%9C%EB%85%90%EB%B6%80%ED%84%B0-%EC%9E%91%EB%8F%99-%EB%B0%A9%EC%8B%9D%EA%B9%8C%EC%A7%80/]    
   
+ 
   
</details>

-----------------------



