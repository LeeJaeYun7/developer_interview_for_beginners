# JPA 프록시와 연관관계 관리


### 프록시란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
 
[참고: 자바 ORM 표준 JPA 프로그래밍] 
 
+ 엔티티를 조회할 때 연관된 엔티티들이 항상 사용되는 것은 아닙니다. <br> 
  예를 들어, 회원 엔티티를 조회할 때, 연관된 팀 엔티티는 비즈니스 로직에 따라 사용될 때도 있지만, <br> 
  그렇지 않을 때도 있습니다. <br> 
  
  JPA는 이런 문제를 해결하려고 엔티티가 실제 사용될 때까지 데이터베이스 조회를 지연하는 방법을 제공하는데, <br> 
  이것을 지연 로딩이라고 합니다. <br> 
  쉽게 이야기해서 team.getName() 처럼 팀 엔티티의 값을 실제 사용하는 시점에 데이터베이스에서 <br> 
  팀 엔티티에 필요한 데이터를 조회하는 것입니다. <br> 
  이 방법을 사용하면 printUser() 메소드는 회원 데이터만 데이터베이스에서 조회해도 됩니다. <br> 
  
  그런데 지연 로딩 기능을 사용하려면 실제 엔티티 객체 대신에 데이터베이스 조회를 지연할 수 있는 <br> 
  가짜 객체가 필요한데, 이것을 프록시 객체라고 합니다. <br> 
 
</details>

-----------------------

### 프록시 객체는 어떻게 동작하는가?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
 
[참고: 자바 ORM 표준 JPA 프로그래밍] 
 
+ JPA에서 식별자로 엔티티 하나를 조회할 때는, EntityManager.find()를 사용합니다. <br> 
  이 메소드는 영속성 컨텍스트에 엔티티가 없으면 데이터베이스를 조회합니다. <br> 
  
  ```
  Member member = em.find(Member.class, "member1");
  ```
  
  이렇게 엔티티를 직접 조회하면 조회한 엔티티를 실제 사용하든 사용하지 않든 <br> 
  데이터베이스를 조회하게 됩니다. <br> 
  엔티티를 실제 사용하는 시점까지 데이터베이스 조회를 미루고 싶으면 <br> 
  EntityManager.getReference() 메소드를 사용하면 됩니다. <br>
  
  ```
  Member member = em.getReference(Member.class, "member1"); 
  ```
  
  이 메소드를 호출할 때 JPA는 데이터베이스를 조회하지 않고 실제 엔티티 객체도 생성하지 않습니다. <br> 
  대신에 데이터베이스 접근을 위임한 프록시 객체를 반환합니다. <br> 
  
  프록시 클래스는 실제 클래스를 상속 받아서 만들어지므로, 실제 클래스와 겉모양이 같습니다. <br> 
  따라서 사용하는 입장에서는 이것이 진짜 객체인지 프록시 객체인지 구분하지 않고 사용하면 됩니다. <br> 
  
  프록시 객체는 실제 객체에 대한 참조(target)를 보관합니다. <br> 
  그리고 프록시 객체의 메소드를 호출하면 프록시 객체는 실제 객체의 메소드를 호출합니다. <br> 
  
</details>

-----------------------


### 프록시 객체는 어떻게 동작하는가?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
 
[참고: 자바 ORM 표준 JPA 프로그래밍] 
 
+ 프록시 객체는 member.getName()처럼 실제 사용될 때, 데이터베이스를 조회해서 실제 엔티티 객체를 생성하는데 <br> 
  이것을 프록시 객체의 초기화라고 합니다. <br> 
  
  1) 프록시 객체에 member.getName()을 호출해서 실제 데이터를 조회합니다. <br> 
  2) 프록시 객체는 실제 엔티티가 생성되어 있지 않으면 영속성 컨텍스트에 실제 엔티티 생성을 요청하는데 이것을 초기화라고 합니다. <br> 
  3) 영속성 컨텍스트는 데이터베이스를 조회해서 실제 엔티티 객체를 생성합니다. <br> 
  4) 프록시 객체는 생성된 실제 엔티티 객체의 참조를 Member target 멤버변수에 보관합니다. <br> 
  5) 프록시 객체는 실제 엔티티 객체의 getName()을 호출해서 결과를 반환합니다. <br> 
</details>

-----------------------

### 프록시의 특징은?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
 
[참고: 자바 ORM 표준 JPA 프로그래밍] 
 
+ 1) 프록시 객체는 처음 사용할 때 한 번만 초기화 됩니다. <br> 
  2) 프록시 객체를 초기화한다고 프록시 객체가 실제 엔티티로 바뀌는 것은 아닙니다. <br> 
     프록시 객체가 초기화되면 프록시 객체를 통해서 실제 엔티티에 접근할 수 있습니다. <br> 
  3) 프록시 객체는 원본 엔티티를 상속받은 객체이므로, 타입 체크 시에 주의해서 사용해야 합니다. <br> 
  4) 영속성 컨텍스트에 찾는 엔티티가 이미 있으면, 데이터베이스를 조회할 필요가 없으므로, <br> 
     em.getReference()를 호출해도 프록시가 아닌 실제 엔티티를 반환합니다. <br> 
  5) 초기화는 영속성 컨텍스트의 도움을 받아 가능합니다. 따라서 영속성 컨텍스트의 도움을 받을 수 없는 <br>
     준영속 상태의 프록시를 초기화하면 문제가 발생합니다. <br> 
     하이버네이트는 org.hibernate.LazyInitializationException 예외를 발생시킵니다. <br> 
</details>

-----------------------

### 즉시 로딩과 지연 로딩이란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
 
[참고: 자바 ORM 표준 JPA 프로그래밍] 
 
+ 즉시 로딩은 엔티티를 조회할 때 연관된 엔티티도 함께 조회합니다. <br> 
  ex) em.find(Member.class, "member1")를 호출할 때 회원 엔티티와 연관된 팀 엔티티도 함께 조회합니다. <br> 
  - 설정 방법: @ManyToOne(fetch = FetchType.EAGER) 
  
  지연 로딩은 연관된 엔티티를 실제 사용할 때 조회합니다. <br> 
  ex) member.getTeam().getName()처럼 조회한 팀 엔티티를 실제 사용하는 시점에 JPA가 SQL을 호출해서 <br> 
      팀 엔티티를 조회합니다. <br> 
  - 설정 방법: @ManyToOne(fetch = FetchType.LAZY) 
  
</details>

-----------------------
