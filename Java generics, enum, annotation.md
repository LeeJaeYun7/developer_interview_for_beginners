# generics, enum, annotation
<br>


### 제네릭의 장점과 단점은?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: 이펙티브 자바 p.153]    
   
+ 제네릭은 자바 5부터 사용할 수 있습니다. <br> 
  제네릭을 지원하기 전에는 컬렉션에서 객체를 꺼낼대마다 형변환을 해야 했습니다. <br>
  그래서 누군가 실수로 엉뚱한 타입의 객체를 넣어두면 런타임에 형변환 오류가 나곤 했습니다. <br> 
  
  반면, 제네릭을 사용하면 컬렉션이 담을 수 있는 타입을 컴파일러에 알려주게 됩니다. <br> 
  그래서 컴파일러는 알아서 형변환 코드를 추가할 수 있게 되고, <br>
  엉뚱한  타입의 객체를 넣으려는 시도를 컴파일 과정에서 차단하여, <br>
  더 안전하고 명확한 프로그램을 만들어 줍니다. <br> 
   
  꼭 컬렉션이 아니더라도, 이러한 이점을 누릴 수 있으나, 코드가 복잡해진다는 단점이 따라옵니다. <br>  
   
[참고: 자바의 정석] 
   
+ JDK 1.5에서 처음 도입된 지네릭스는 JDK 1.8부터 도입된 람다식만큼 큰 변화였습니다. <br> 
  그 당시만 해도 지네릭스는 선택적으로 사용하는 경우가 많았지만, 이제는 지네릭스를 모르고는 Java API문서조차 <br>
  제대로 보기 어려울 만큼 중요한 위치를 차지하고 있습니다. <br> 
   
  이번 장을 다 이해했다고 해서 지네릭스를 완전히 이해할 수는 없을 것입니다. <br> 
  이 장에서는 기본적인 개념정도만 익히고, 다른 장을 통해서 지네릭스가 실제로 어떻게 활용되는지 배움으로써 <br>
  보다 깊게 이해하게 될 것입니다. <br> 
  지네릭스가 잘 이해되지 않는다고 해서 이 장에만 너무 머물러 있지 않기를 당부하는 바입니다. <br> 
  
  지네릭스는 다양한 타입의 객체들을 다루는 메서드나 컬렉션 클래스에 컴파일 시의 타입 체크(compile-time check)를 해주는 기능입니다. <br> 
  객체의 타입을 컴파일 시에 체크하기 때문에 객체의 타입 안정성을 높이고, 형변환의 번거로움이 줄어듭니다. <br> 
  
  타입 안정성을 높인다는 것은 의도하지 않은 타입의 객체가 저장되는 것을 막고, 저장된 객체를 꺼내올 때, 원래의 타입과 다른 타입으로 <br> 
  잘못 형변환되어 발생할 수 있는 오류를 줄여준 다는 뜻입니다. <br> 
   
  예를 들어, ArrayList와 같은 컬렉션 클래스는 다양한 종류의 객체를 담을 수 있긴 하지만, <br> 
  보통 한 종류의 객체를 담는 경우가 더 많습니다. <br> 
  그런데도 꺼낼 때마다 타입체크를 하고, 형변환을 하는 것은 아무래도 불편할 수 밖에 없습니다. <br> 
  게다가 원하지 않는 종류의 객체가 포함되는 것을 막을 방법이 없다는 것도 문제입니다. <br> 
  이러한 문제들을 지네릭스가 해결해줍니다. 
</details>

-----------------------


### enum이란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
   
[참고: 자바의 정석]   
+ 열거형은 서로 관련된 상수를  편리하게 선언하기 위한 것으로 여러 상수를 정의할 때 사용하면 유용합니다. <br>
  원래 자바는 C언어와 달리 열거형이라는 것이 존재하지 않았으나, JDK 1.5부터 새로 추가되었습니다. <br> 
  자바의 열거형은 C언어의 열거형보다 더 향상된 것으로 열거형이 갖는 값뿐만 아니라 타입도 관리하기 때문에, <br> 
  논리적인 오류를 줄일 수 있습니다. 
   
[참고: 이펙티브 자바] 
+ 열거 타입은 일정 개수의 상수 값을 정의 한 다음, 그 외의 값은 허용하지 않는 타입입니다. <br> 
  사계절, 태양계의 행성, 카드게임의 카드 종류 등이 좋은 예입니다. <br> 
  다음은 열거 타입의 가장 단순한 형태입니다. <br> 
   
  public enum APPLE { FUJI, PIPPIN, GRANNY_SMITH} <br> 
  public enum Orange { NAVEL, TEMPLE, BLOOD} <br> 
   
  겉보기에는 C, C++, C# 같은 다른 언어의 열거 타입과 비슷하지만, <br> 
  보이는 것이 다가 아닙니다. <br> 
  자바의 열거 타입은 완전항 형태의 클래스라서, 다른 언어의 열거 타입보다 훨씬 강력합니다. <br> 
  
  자바 열거 타입을 뒷받침하는 아이디어는 단순합니다. <br> 
  열거 타입 자체는 클래스이며, 상수 하나당 자신의 인스턴스를 하나씩 만들어 <br> 
  public static final 필드로 공개합니다. <br> 
   
  열거 타입은 밖에서 접근할 수 있는 생성자를 제공하지 않으므로, 사실상 final입니다. <br> 
  따라서 클라이언트가 인스턴스를 직접 생성하거나 확장할 수 없으니, <br>
  열거 타입 선언으로 만들어진 인스턴스들은 딱 하나씩만 존재합니다. <br> 
   
  다시 말해 열거 타입은 인스턴스 통제됩니다. <br>
  싱글턴은 원소가 하나뿐인 열거 타입이라 할 수 있고, <br>
  거꾸로 열거 타입은 싱글턴을 일반화한 형태라고 볼 수 있습니다. <br>

    
</details>

-----------------------


### 애너테이션이란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: 자바의 정석] 
   
+ 프로그램의 소스코드 안에 다른 프로그램을 위한 정보를 미리 약속된 형식으로 포함시킨 것이 <br>
  바로 애너테이션입니다. <br> 
  애너테이션은 주석(comment)처럼 프로그래밍 언어에 영향을 미치지 않으면서도 <br>
  다른 프로그램에게 유용한 정보를 제공할 수 있다는 장점이 있습니다. 
  
  예를 들어, 자신이 작성한 소스코드 중에서 특정 메서드만 테스트하기를 원한다면, <br> 
  다음과 같이 '@Test'라는 애너테이션을 메서드 앞에 붙입니다. <br> 
  '@Test'는 이 메서드를 테스트해야 한다는 것을 테스트 프로그램에게 알리는 역할을 할 뿐, <br> 
  메서드가 포함된 프로그램 자체에는 아무런 영향을 미치지 않습니다. <br>
  주석처럼 존재하지 않는 것이나 다름 없습니다. <br> 
  
  
</details>

-----------------------
