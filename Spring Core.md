# Spring Core
<br>


-----------------------

### IoC란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
   
+ IoC란 Inversion Of Control의 줄임말로, 프로그램의 제어권을 프레임워크가 가져가는 것을 의미합니다.  

[참고: 토비의 스프링]

+ IoC는 소프트웨어에서 자주 발견할 수 있는 일반적인 개념입니다. <br> 
  객체지향 설계나, 디자인 패턴, 컨테이너에서 동작하는 서버 기술을 사용한다면 자연스럽게 <br> 
  IoC를 적용하거나 그 원리로 동작하는 기술을 사용하게 될 것입니다. <br> 
  DaoFactory처럼 객체를 생성하고 관계를 맺어주는 등의 작업을 담당하는 기능을 일반화한 것이 스프링의 IoC 컨테이너입니다. <br> 
   
  한 가지 짚고 넘어갈 것은 여기서 사용하는 IoC라는 용어인데, IoC가 매우 느슨하게 정의돼서 폭넓게 사용되는 용어라는 점입니다. <br> 
  때문에 스프링을 IoC컨테이너라고만 해서는 스프링이 제공하는 기능의 특징을 명확하게 설명하지는 못합니다. <br> 
  
  스프링이 서블릿 컨테이너처럼 서버에서 동작하는 서비스 컨테이너라는 뜻인지, 아니면 단순히 IoC 개념이 적용된 <br> 
  템플릿 메소드 패턴을 이용해 만들어진 프레임워크인지 <br> 
  아니면 또 다른 IoC 특징을 지닌 기술이라는 것인지 파악하기 힘듭니다. <br> 
   
  그래서 새로운 용어를 만드는 데 탁월한 재능이 있는 몇몇 사람의 제안으로 스프링이 제공하는 IoC 방식을 핵심을 짚어주는 <br> 
  의존 관계 주입(Dependency Injection)이라는, 좀 더 의도가 명확히 드러나는 이름을 사용하기 시작했습니다. <br> 
  
  스프링 IoC 기능의 대푲거인 동작 원리는 주로 의존관계 주입이라고 불립니다. <br> 
  물론 스프링이 컨테이너이고, 프레임워크이니 기본적인 동작 원리가 모두 IoC 방식이라고 할 수 있지만, <br> 
  스프링이 여타 프레임워크와 차별화돼서 제공해주는 기능은 의존관계 주입이라는 새로운 용어를 사용할 때 분명히 드러납니다. <br> 
  
  그래서 초기에는 주로 IoC 컨테이너라고 불리던 스프링이 지금은 의존관계 주입 컨테이너 또는 그 영문약자를 써서 <br> 
  DI 컨테이너라고 더 많이 불리고 있습니다. 
   
</details>

-----------------------

### 의존 관계 주입 방법에는 무엇이 있는가?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: 김영한 스프링 코어]    
   
+ 생성자 주입, 수정자 주입(setter 주입), 필드 주입, 일반 메서드 주입 등이 있습니다.  
</details>

-----------------------

### 생성자 주입이란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: 김영한 스프링 코어]    
   
+ 이름 그대로 생성자를 통해서 주입을 받는 방식입니다. <br> 
  생성자 주입은 생성자 호출 시점에 딱 1번만 호출되는 것을 보장합니다. <br> 
  따라서 불변, 필수 의존 관계에 활용합니다. <br> 
  이 때, 생성자가 딱 1개만 있다면 @Autowired를 생략할 수 있습니다. 
</details>

-----------------------

### setter 주입이란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: 김영한 스프링 코어]    
   
+ setter라 불리는 필드의 값을 변경하는 수정자 메서드를 통해서 의존관계를 주입하는 방법입니다. <br> 
  선택, 변경 가능성이 있는 의존관계에 사용합니다. 
   
[참고: 토비의 스프링] 
   
+ 수정자 메소드는 외부에서 오브젝트 내부의 애트리뷰트 값을 변경하려는 용도로 주로 사용됩니다. <br> 
  메소드는 항상 set으로 시작합니다. 간단히 수정자라고 불리기도 합니다. <br> 
  수정자 메소드의 핵심 기능은 파라미터로 전달된 값을 보통 내부의 인스턴스 변수에 저장하는 것입니다. <br> 
  부가적으로 입력 값에 대한 검증이나 그 밖의 작업을 수행할 수도 있습니다. <br> 
  수정자 메소드는 외부로부터 제공받은 오브젝트 레퍼런스를 저장해뒀다가 <br> 
  내부의 메소드에서 사용하게 하는 DI 방식에서 활용하기에 적당합니다. 
   
</details>

-----------------------

### 필드 주입이란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: 김영한 스프링 코어]    
   
+ 이름 그대로 필드에 바로 주입하는 방법입니다. <br> 
  코드가 간결해서 많은 개발자들을 유혹하지만, 외부에서 변경이 불가능해서 테스트 하기 힘들다는 치명적인 단점이 있습니다. <br> 
  DI 프레임워크가 없으면 아무것도 할 수 없습니다. <br>  
   
</details>

-----------------------

### 필드 주입에서, 외부에서 변경이 불가능해서 테스트 하기 힘들다는 치명적인 단점이 있다는 의미가 무엇입니까?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: 김영한 스프링 코어]    
   
+ 
   
</details>

-----------------------

### 필드 주입에서, DI 프레임워크가 없으면 아무것도 할 수 없다는 것이 무엇입니까?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: 김영한 스프링 코어]    
   
+ 
   
</details>

-----------------------


### 일반 메서드 주입이란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
+ 일반 메서드를 통해서 주입 받을 수 있습니다. <br>
  한 번에 여러 필드를 주입 받을 수 있지만, 일반적으로 잘 사용하지 않습니다.  
   
</details>

-----------------------

### 프레임워크 vs 라이브러리?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
+ 내가 작성한 코드의 제어권을 가져가는 것을 프레임워크라고 합니다. <br>
  반면, 라이브러리는 내가 작성한 코드의 제어권을 가져가지 않습니다. 
</details>

-----------------------

### DI란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
+ 실행 시점에 외부에서 실제 구현 객체를 생성하고, 클라이언트에 전달해서 클라이언트와 서버의 실제 의존 관계가 연결되는 것
</details>

-----------------------


### DI의 장점은?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
+ DI를 사용하면 정적인 클래스 의존 관계를 변경하지 않고, 동적인 객체 의존 관계를 쉽게 변경할 수 있습니다. <br> 
  즉, 코드의 유연성과 유지보수성이 높아진다는 장점이 있습니다. 
</details>

-----------------------

### 스프링 빈의 생명주기란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: 김영한 스프링 핵심 원리] 
   
+ 데이터베이스 커넥션 풀이나, 네트워크 소켓처럼 애플리케이션 시작 시점에 필요한 연결을 미리 해두고, <br>
  애플리케이션 종료 시점에 연결을 모두 종료하는 작업을 진행하려면 <br> 
  객체의 초기화와 종료 작업이 필요합니다. 
   
  스프링 빈은 '객체 생성 -> 의존 관계 주입'의 라이프 사이클을 갖습니다. <br>
  즉, 스프링 빈은 객체를 생성하고 의존 관계 주입이 다 끝난 다음에야 필요한 데이터를 사용할 수 있는 준비가 완료됩니다. <br>
  따라서 초기화 작업은 의존관계 주입이 모두 완료되고 난 다음에 호출해야 합니다. <br> 
  그런데 개발자가 의존 관계 주입이 모두 완료된 시점을 어떻게 알 수 있을까? <br> 
   
  스프링은 의존관계 주입이 완료되면 스프링 빈에게 콜백 메서드를 통해서 초기화 시점을 알려주는 다양한 기능을 제공합니다. <br>
  또한, 스프링은 스프링 컨테이너가 종료되기 직전에 소멸 콜백을 줍니다. <br> 
  따라서 안전하게 종료 작업을 진행할 수 있습니다. 
   
  즉, 스프링 빈의 이벤트 라이프사이클은 다음과 같습니다. <br>
  스프링 컨테이너 생성 -> 스프링 빈 생성 -> 의존 관계 주입 -> 초기화 콜백 -> 사용 -> 소멸전 콜백 -> 스프링 종료  
</details>

-----------------------

### @Configuration 애노테이션이란 무엇인가?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: 스프링 인 액션] 
   
+ @Configuration 애노테이션은 이것이 각 빈을 스프링 애플리케이션 컨텍스트에 제공하는 구성 클래스라는 것을 <br>
  스프링에게 알려줍니다. <br>
  구성 클래스의 메서드에는 @Bean 애노테이션이 저장되어 있으며, 이것은 각 메서드에서 반환되는 객체가 <br>
  애플리케이션 컨텍스트의 빈으로 추가되어야 한다는 것을 나타냅니다. 
</details>

-----------------------

### 자동 구성이란 무엇입니까?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: 스프링 인 액션] 
   
+ 자동 구성은 자동 연결(autowiring)과 컴포넌트 검색(component scanning)이라는 스프링 기법을 기반으로 합니다. <br> 
  컴포넌트 검색을 사용하여 스프링은 자동으로 애플리케이션의 classpath에 지정된 컴포넌트를 찾은 후 <br>
  스프링 애플리케이션 컨텍스트의 빈으로 생성할 수 있습니다. <br> 
   
  또한, 스프링은 자동 연결을 사용하여 의존 관계가 있는 컴포넌트를 자동으로 다른 빈에 주입합니다. 
</details>

-----------------------

### @SpringBootApplication은 어떤 어노테이션이 결합한 것입니까?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: 스프링 인 액션] 
   
+ @SpringBootConfiguration, @EnableAutoConfiguration, @ComponentScan이 세 가지가 결합한 것입니다. <br>
  
  @SpringBootConfiguration은 현재 클래스를 구성 클래스로 지정하는 역할을 합니다. <br> 
  이 애노테이션은 @Configuration 애노테이션의 특화된 형태입니다. <br> 
   
  @EnableAutoConfiguration은 스프링 부트 자동 구성을 활성화 합니다. <br> 
  이 애노테이션은 우리가 필요로 하는 컴포넌트들을 자동으로 구성하도록 합니다. <br> 
   
  @ComponentScan은 컴포넌트 검색을 활성화합니다. 이것은 @Component, @Controller, @Service 등의 애노테이션과 함께 <br> 
  클래스를 선언할 수 있게 해줍니다. <br>
  그러면 스프링은 자동으로 그런 클래스를 찾아 스프링 애플리케이션 컨텍스트에 컴포넌트로 등록합니다. <br> 
   
</details>

-----------------------

### Lombok이란 무엇인가?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: 스프링 인 액션] 
   
+ Lombok은 생성자 혹은 게터, 세터 메서드 등을 런타임 시에 자동으로 생성하게 하는 라이브러리입니다. <br> 
  예를 들어, @Data 애노테이션을 지정하면 소스 코드에 누락된 final 속성들을 초기화하는 생성자는 물론이고, <br> 
  속성들의 게터와 세터 등을 생성하라고 Lombok에 알려줍니다. 
   
</details>

-----------------------


### 빈 스코프란 무엇인가?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: spring-reference.pdf] 
   
+ 개발자는 특정 빈의 정의로부터 생성되는 객체에 어떤 의존성과 설정 값이 플러그인되는지 컨트롤 할 수 있을 뿐만 아니라, <br>
  객체의 스코프까지 컨트롤 할 수 있습니다. <br> 
  이러한 접근법은 매우 강력하고, 개발자가 자바 클래스 레벨에서 객체의 스코프를 '굽는' 대신, <br>
  설정을 통해 생성하는 객체의 스코프를 선택할 수 있는 유연성을 부여합니다. <br>    
   
  빈들은 여러 스코프 중 하나로 배포될 수 있도록 정의됩니다. <br> 
  스프링 프레임워크는 정확히 5개의 스코프를 지원합니다. <br> 
   
  그것은 싱글턴, 프로토타입, 리퀘스트, 세션, 글로벌 세션입니다.  
   
</details>

-----------------------

### 스프링 빈이란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: 토비의 스프링 p.101] 
   
+ 
빈 또는 빈 오브젝트는 스프링이 IoC 방식으로 관리하는 오브젝트라는 뜻입니다.
관리되는 오브젝트라고 부르기도 합니다.
주의할 점은 스프링을 사용하는 애플리케이션에서 만들어지는 모든 오브젝트가 다 빈은
아니라는 사실입니다.
그 중에서 스프링이 직접 그 생성과 제어를 담당하는 오브젝트만을 빈이라고 부릅니다.
   
</details>

-----------------------

### 빈 팩토리란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: 토비의 스프링 p.101] 
   
+ 
스프링의 IoC를 담당하는 핵심 컨테이너를 가리킵니다.
빈을 등록하고, 생성하고, 조회하고 돌려주고, 그 외에 부가적인 빈을 관리하는 기능을 담당합니다.
보통은 이 빈 팩토리를 바로 사용하지 않고 이를 확장한 애플리케이션 컨텍스트를 이용합니다.
BeanFactory라고 붙여쓰면 빈 팩토리가 구현하고 있는 가장 기본적인 인터페이스의 이름이 됩니다.
이 인터페이스에 getBean()과 같은 메소드가 정의되어 있습니다.
   
</details>

-----------------------

### 애플리케이션 컨텍스트란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: 토비의 스프링 p.101] 
   
+ 
빈 팩토리를 확장한 IoC 컨테이너입니다. 빈을 등록하고 관리하는 기본적인 기능은 빈 팩토리와 동일합니다. 여기에 스프링이 제공하는 각종 부가 서비스를 추가로 제공합니다.

빈 팩토리라고 부를 때는 주로 빈의 생성과 제어의 관점에서 이야기하는 것이고,
애플리케이션 컨텍스트라고 할 때는 스프링이 제공하는 애플리케이션 지원 기능을 
모두 포함해서 이야기하는 것이라고 보면 됩니다. 
스프링에서는 애플리케이션 컨텍스트라는 용어를 빈 팩토리보다 더 많이 사용합니다.
ApplicationContext라고 적으면 애플리케이션 컨텍스트가 구현해야 하는 기본 인터페이스를
가리키는 것이기도 합니다. 
ApplicationContext는 BeanFactory를 상속합니다. 
   
</details>

-----------------------
