# Spring Core
<br>


-----------------------

### IoC란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
   
+ IoC란 Inversion Of Control의 줄임말로, 프로그램의 제어권을 프레임워크가 가져가는 것을 의미합니다.  

[참고: 토비의 스프링]

+ IoC는 소프트웨어에서 자주 발견할 수 있는 일반적인 개념입니다. <br> 
  객체지향 설계나, 디자인 패턴, 컨테이너에서 동작하는 서버 기술을 사용한다면 자연스럽게 <br> 
  IoC를 적용하거나 그 원리로 동작하는 기술을 사용하게 될 것입니다. <br> 
  DaoFactory처럼 객체를 생성하고 관계를 맺어주는 등의 작업을 담당하는 기능을 일반화한 것이 스프링의 IoC 컨테이너입니다. <br> 
   
  한 가지 짚고 넘어갈 것은 여기서 사용하는 IoC라는 용어인데, IoC가 매우 느슨하게 정의돼서 폭넓게 사용되는 용어라는 점입니다. <br> 
  때문에 스프링을 IoC컨테이너라고만 해서는 스프링이 제공하는 기능의 특징을 명확하게 설명하지는 못합니다. <br> 
  
  스프링이 서블릿 컨테이너처럼 서버에서 동작하는 서비스 컨테이너라는 뜻인지, 아니면 단순히 IoC 개념이 적용된 <br> 
  템플릿 메소드 패턴을 이용해 만들어진 프레임워크인지 <br> 
  아니면 또 다른 IoC 특징을 지닌 기술이라는 것인지 파악하기 힘듭니다. <br> 
   
  그래서 새로운 용어를 만드는 데 탁월한 재능이 있는 몇몇 사람의 제안으로 스프링이 제공하는 IoC 방식을 핵심을 짚어주는 <br> 
  의존 관계 주입(Dependency Injection)이라는, 좀 더 의도가 명확히 드러나는 이름을 사용하기 시작했습니다. <br> 
  
  스프링 IoC 기능의 대표적인 동작 원리는 주로 의존관계 주입이라고 불립니다. <br> 
  물론 스프링이 컨테이너이고, 프레임워크이니 기본적인 동작 원리가 모두 IoC 방식이라고 할 수 있지만, <br> 
  스프링이 여타 프레임워크와 차별화돼서 제공해주는 기능은 의존관계 주입이라는 새로운 용어를 사용할 때 분명히 드러납니다. <br> 
  
  그래서 초기에는 주로 IoC 컨테이너라고 불리던 스프링이 지금은 의존관계 주입 컨테이너 또는 그 영문약자를 써서 <br> 
  DI 컨테이너라고 더 많이 불리고 있습니다. 
   
</details>

-----------------------

### 의존 관계 주입 방법에는 무엇이 있는가?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: 김영한 스프링 코어]    
   
+ 생성자 주입, 수정자 주입(setter 주입), 필드 주입, 일반 메서드 주입 등이 있습니다.  
</details>

-----------------------

### 생성자 주입이란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: 김영한 스프링 코어]    
   
+ 이름 그대로 생성자를 통해서 주입을 받는 방식입니다. <br> 
  생성자 주입은 생성자 호출 시점에 딱 1번만 호출되는 것을 보장합니다. <br> 
  따라서 불변, 필수 의존 관계에 활용합니다. <br> 
  이 때, 생성자가 딱 1개만 있다면 @Autowired를 생략할 수 있습니다. 
</details>

-----------------------

### setter 주입이란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: 김영한 스프링 코어]    
   
+ setter라 불리는 필드의 값을 변경하는 수정자 메서드를 통해서 의존관계를 주입하는 방법입니다. <br> 
  선택, 변경 가능성이 있는 의존관계에 사용합니다. 
   
[참고: 토비의 스프링] 
   
+ 수정자 메소드는 외부에서 오브젝트 내부의 애트리뷰트 값을 변경하려는 용도로 주로 사용됩니다. <br> 
  메소드는 항상 set으로 시작합니다. 간단히 수정자라고 불리기도 합니다. <br> 
  수정자 메소드의 핵심 기능은 파라미터로 전달된 값을 보통 내부의 인스턴스 변수에 저장하는 것입니다. <br> 
  부가적으로 입력 값에 대한 검증이나 그 밖의 작업을 수행할 수도 있습니다. <br> 
  수정자 메소드는 외부로부터 제공받은 오브젝트 레퍼런스를 저장해뒀다가 <br> 
  내부의 메소드에서 사용하게 하는 DI 방식에서 활용하기에 적당합니다. 
   
</details>

-----------------------

### 필드 주입이란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: 김영한 스프링 코어]    
   
+ 이름 그대로 필드에 바로 주입하는 방법입니다. <br> 
  코드가 간결해서 많은 개발자들을 유혹하지만, 외부에서 변경이 불가능해서 테스트 하기 힘들다는 치명적인 단점이 있습니다. <br> 
  DI 프레임워크가 없으면 아무것도 할 수 없습니다. <br>  
   
</details>

-----------------------

### 필드 주입에서, 외부에서 변경이 불가능해서 테스트 하기 힘들다는 치명적인 단점이 있다는 의미가 무엇입니까?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: 김영한 스프링 코어]    
   
+ 
   
</details>

-----------------------

### 필드 주입에서, DI 프레임워크가 없으면 아무것도 할 수 없다는 것이 무엇입니까?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: 김영한 스프링 코어]    
   
+ 
   
</details>

-----------------------


### 일반 메서드 주입이란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
+ 일반 메서드를 통해서 주입 받을 수 있습니다. <br>
  한 번에 여러 필드를 주입 받을 수 있지만, 일반적으로 잘 사용하지 않습니다.  
   
</details>

-----------------------

### 프레임워크 vs 라이브러리?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
+ 내가 작성한 코드의 제어권을 가져가는 것을 프레임워크라고 합니다. <br>
  반면, 라이브러리는 내가 작성한 코드의 제어권을 가져가지 않습니다. 
</details>

-----------------------

### DI란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
+ 실행 시점에 외부에서 실제 구현 객체를 생성하고, 클라이언트에 전달해서 클라이언트와 서버의 실제 의존 관계가 연결되는 것
</details>

-----------------------


### DI의 장점은?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
+ DI를 사용하면 정적인 클래스 의존 관계를 변경하지 않고, 동적인 객체 의존 관계를 쉽게 변경할 수 있습니다. <br> 
  즉, 코드의 유연성과 유지보수성이 높아진다는 장점이 있습니다. 
</details>

-----------------------

### 스프링 빈의 생명주기란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: 김영한 스프링 핵심 원리] 
   
+ 데이터베이스 커넥션 풀이나, 네트워크 소켓처럼 애플리케이션 시작 시점에 필요한 연결을 미리 해두고, <br>
  애플리케이션 종료 시점에 연결을 모두 종료하는 작업을 진행하려면 <br> 
  객체의 초기화와 종료 작업이 필요합니다. 
   
  스프링 빈은 '객체 생성 -> 의존 관계 주입'의 라이프 사이클을 갖습니다. <br>
  즉, 스프링 빈은 객체를 생성하고 의존 관계 주입이 다 끝난 다음에야 필요한 데이터를 사용할 수 있는 준비가 완료됩니다. <br>
  따라서 초기화 작업은 의존관계 주입이 모두 완료되고 난 다음에 호출해야 합니다. <br> 
  그런데 개발자가 의존 관계 주입이 모두 완료된 시점을 어떻게 알 수 있을까? <br> 
   
  스프링은 의존관계 주입이 완료되면 스프링 빈에게 콜백 메서드를 통해서 초기화 시점을 알려주는 다양한 기능을 제공합니다. <br>
  또한, 스프링은 스프링 컨테이너가 종료되기 직전에 소멸 콜백을 줍니다. <br> 
  따라서 안전하게 종료 작업을 진행할 수 있습니다. 
   
  즉, 스프링 빈의 이벤트 라이프사이클은 다음과 같습니다. <br>
  스프링 컨테이너 생성 -> 스프링 빈 생성 -> 의존 관계 주입 -> 초기화 콜백 -> 사용 -> 소멸전 콜백 -> 스프링 종료  
</details>

-----------------------

### @Configuration 애노테이션이란 무엇인가?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: 스프링 인 액션] 
   
+ @Configuration 애노테이션은 이것이 각 빈을 스프링 애플리케이션 컨텍스트에 제공하는 구성 클래스라는 것을 <br>
  스프링에게 알려줍니다. <br>
  구성 클래스의 메서드에는 @Bean 애노테이션이 저장되어 있으며, 이것은 각 메서드에서 반환되는 객체가 <br>
  애플리케이션 컨텍스트의 빈으로 추가되어야 한다는 것을 나타냅니다. 
</details>

-----------------------

### 자동 구성이란 무엇입니까?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: 스프링 인 액션] 
   
+ 자동 구성은 자동 연결(autowiring)과 컴포넌트 검색(component scanning)이라는 스프링 기법을 기반으로 합니다. <br> 
  컴포넌트 검색을 사용하여 스프링은 자동으로 애플리케이션의 classpath에 지정된 컴포넌트를 찾은 후 <br>
  스프링 애플리케이션 컨텍스트의 빈으로 생성할 수 있습니다. <br> 
   
  또한, 스프링은 자동 연결을 사용하여 의존 관계가 있는 컴포넌트를 자동으로 다른 빈에 주입합니다. 
</details>

-----------------------

### @SpringBootApplication은 어떤 어노테이션이 결합한 것입니까?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: 스프링 인 액션] 
   
+ @SpringBootConfiguration, @EnableAutoConfiguration, @ComponentScan이 세 가지가 결합한 것입니다. <br>
  
  @SpringBootConfiguration은 현재 클래스를 구성 클래스로 지정하는 역할을 합니다. <br> 
  이 애노테이션은 @Configuration 애노테이션의 특화된 형태입니다. <br> 
   
  @EnableAutoConfiguration은 스프링 부트 자동 구성을 활성화 합니다. <br> 
  이 애노테이션은 우리가 필요로 하는 컴포넌트들을 자동으로 구성하도록 합니다. <br> 
   
  @ComponentScan은 컴포넌트 검색을 활성화합니다. 이것은 @Component, @Controller, @Service 등의 애노테이션과 함께 <br> 
  클래스를 선언할 수 있게 해줍니다. <br>
  그러면 스프링은 자동으로 그런 클래스를 찾아 스프링 애플리케이션 컨텍스트에 컴포넌트로 등록합니다. <br> 
   
</details>

-----------------------

### Lombok이란 무엇인가?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: 스프링 인 액션] 
   
+ Lombok은 생성자 혹은 게터, 세터 메서드 등을 런타임 시에 자동으로 생성하게 하는 라이브러리입니다. <br> 
  예를 들어, @Data 애노테이션을 지정하면 소스 코드에 누락된 final 속성들을 초기화하는 생성자는 물론이고, <br> 
  속성들의 게터와 세터 등을 생성하라고 Lombok에 알려줍니다. 
   
</details>

-----------------------


### 빈 스코프란 무엇인가?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: spring-reference.pdf] 
   
+ 개발자는 특정 빈의 정의로부터 생성되는 객체에 어떤 의존성과 설정 값이 플러그인되는지 컨트롤 할 수 있을 뿐만 아니라, <br>
  객체의 스코프까지 컨트롤 할 수 있습니다. <br> 
  이러한 접근법은 매우 강력하고, 개발자가 자바 클래스 레벨에서 객체의 스코프를 '굽는' 대신, <br>
  설정을 통해 생성하는 객체의 스코프를 선택할 수 있는 유연성을 부여합니다. <br>    
   
  빈들은 여러 스코프 중 하나로 배포될 수 있도록 정의됩니다. <br> 
  스프링 프레임워크는 정확히 5개의 스코프를 지원합니다. <br> 
   
  그것은 싱글턴, 프로토타입, 리퀘스트, 세션, 글로벌 세션입니다.  

[참고: 토비의 스프링 p.111] 
   
+  스프링이 관리하는 오브젝트, 즉 빈이 생성되고, 존재하고 적용되는 범위에 대해 알아보자.
  스프링에서는 이것을 빈의 스코프(scope)라고 한다. 
  스프링 빈의 기본 스코프는 싱글톤이다. 싱글톤 스코프는 컨테이너 내에 한 개의 
  오브젝트만 만들어져서, 강제로 제거하지 않는 한 스프링 컨테이너가 존재하는 동안 계속 유지된다. 스프링에서 만들어지는 대부분의 빈은 싱글톤 스코프를 갖는다. 
   경우에 따라서는 싱글톤 외의 스코프를 가질 수 있다. 대표적으로 프로토타입 스코프가 있다.
   프로토타입은 싱글톤과 달리 컨테이너에 빈을 요청할 때마다 매번 새로운 오브젝트를 만들어준다.
   그 외에도 웹을 통해 새로운 HTTP 요청이 생길때마다 생성되는 요청(request) 스코프가 있고,
   웹의 세션과 스코프가 유사한 세션 스코프도 있다.
   스프링에서 만들어지는 빈의 스코프는 싱글톤 외에도 다양한 스코프를 사용할 수 있다.
   싱글톤 외의 빈의 스코프에 대해서는 10장에서 자세히 알아보겠다. 


</details>

-----------------------

### 스프링 빈이란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: 토비의 스프링 p.101] 
   
+ 
빈 또는 빈 오브젝트는 스프링이 IoC 방식으로 관리하는 오브젝트라는 뜻입니다.
관리되는 오브젝트라고 부르기도 합니다.
주의할 점은 스프링을 사용하는 애플리케이션에서 만들어지는 모든 오브젝트가 다 빈은
아니라는 사실입니다.
그 중에서 스프링이 직접 그 생성과 제어를 담당하는 오브젝트만을 빈이라고 부릅니다.
   
</details>

-----------------------

### 빈 팩토리란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: 토비의 스프링 p.101] 
   
+ 
스프링의 IoC를 담당하는 핵심 컨테이너를 가리킵니다.
빈을 등록하고, 생성하고, 조회하고 돌려주고, 그 외에 부가적인 빈을 관리하는 기능을 담당합니다.
보통은 이 빈 팩토리를 바로 사용하지 않고 이를 확장한 애플리케이션 컨텍스트를 이용합니다.
BeanFactory라고 붙여쓰면 빈 팩토리가 구현하고 있는 가장 기본적인 인터페이스의 이름이 됩니다.
이 인터페이스에 getBean()과 같은 메소드가 정의되어 있습니다.
   
</details>

-----------------------

### 애플리케이션 컨텍스트란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: 토비의 스프링 p.101] 
   
+ 
빈 팩토리를 확장한 IoC 컨테이너입니다. 빈을 등록하고 관리하는 기본적인 기능은 빈 팩토리와 동일합니다. 여기에 스프링이 제공하는 각종 부가 서비스를 추가로 제공합니다.

빈 팩토리라고 부를 때는 주로 빈의 생성과 제어의 관점에서 이야기하는 것이고,
애플리케이션 컨텍스트라고 할 때는 스프링이 제공하는 애플리케이션 지원 기능을 
모두 포함해서 이야기하는 것이라고 보면 됩니다. 
스프링에서는 애플리케이션 컨텍스트라는 용어를 빈 팩토리보다 더 많이 사용합니다.
ApplicationContext라고 적으면 애플리케이션 컨텍스트가 구현해야 하는 기본 인터페이스를
가리키는 것이기도 합니다. 
ApplicationContext는 BeanFactory를 상속합니다. 
   
</details>

-----------------------

### 싱글톤 레지스트리로서의 애플리케이션 컨텍스트란 무엇입니까?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: 토비의 스프링 p.101] 
   
+ 애플리케이션 컨텍스트는 우리가 만들었던 오브젝트 팩토리와 비슷한 방식으로 동작하는 IoC 컨테이너입니다. 그러면서 동시에 이 애플리케이션 컨텍스트는 싱글톤을 저장하고 관리하는 싱글톤 레지스트리이기도 합니다. 

스프링은 기본적으로 별다른 설정을 하지 않으면 내부에서 생성하는 빈 오브젝트를 모두 싱글톤으로 만듭니다. 여기서 싱글톤이라는 것은 디자인 패턴에서 나오는 싱글톤 패턴과 비슷한 개념이지만, 그 구현 방법은 확연히 다릅니다. 

왜 스프링은 싱글톤으로 빈을 만드는 것일까? 이는 스프링이 주로 적용되는 대상이 자바 엔터프라이즈 기술을 사용하는 서버환경이기 때문이다. 물론 스프링으로 PC 등에서 동작하는 독립형 윈도우 프로그램 같은 걸 개발할 수도 있긴 하지만, 실제로는 극히 드물다.
태생적으로 스프링은 엔터프라이즈 시스템을 위해 고안된 기술이기 때문에 서버 환경에서 사용될 때, 그 가치가 있다. 실제로 스프링은 대부분 서버환경에서 사용된다.

스프링이 처음 설계됐던 대규모의 엔터프라이즈 서버환경은 서버 하나당 최대로 초당 수십에서 수백 번씩 브라우저나 여타 시스템으로부터의 요청을 받아 처리할 수 있는 높은 성능이 요구되는 환경이었다. 또 하나의 요청을 처리하기 위해 데이터 액세스 로직, 서비스 로직, 비즈니스 로직, 프레젠테이션 로직 등의 다양한 기능을 담당하는 오브젝트들이 참여하는 계층형 구조로 이뤄진 경우가 대부분이다. 비즈니스 로직도 복잡한 경우가 많다. 

그런데 매번 클라이언트에서 요청이 올 때마다 각 로직을 담당하는 오브젝트를 새로 만들어서 사용한다고 생각해보자. 요청 한 번에 5개의 오브젝트가 새로 만들어지고 초당 500개의 요청이 들어오면, 초당 2500개의 새로운 오브젝트가 생성된다. 1분이면 십오만 개, 한 시간이면 9백만 개의 새로운 오브젝트가 만들어진다. 아무리 자바의 오브젝트 생성과 가비지 컬렉션의 성능이 좋아졌다고 한들 이렇게 부하가 걸리면 서버가 감당하기 힘들다. 

그래서 엔터프라이즈 분야에서는 서비스 오브젝트라는 개념을 일찍부터 사용해왔다.
서블릿은 자바 엔터프라이즈 기술의 가장 기본이 되는 서비스 오브젝트라고 할 수 있다.
스펙에서 강제하진 않지만, 서블릿은 대부분 멀티스레드 환경에서 싱글톤으로 동작한다.
서블릿 클래스당 하나의 오브젝트만 만들어두고, 
사용자의 요청을 담당하는 여러 스레드에서 하나의 오브젝트를 공유해 동시에 사용한다. 

이렇게 애플리케이션 안에 제한된 수, 대개 한 개의 오브젝트만 만들어서 사용하는 것이
싱글톤 패턴의 원리다. 
따라서 서버환경에서는 서비스 싱글톤의 사용이 권장된다.
하지만 디자인 패턴에 소개된 싱글톤 패턴은 사용하기가 까다롭고 여러 가지 문제점이 있다. 
그래서 심지어 이런 싱글톤 패턴을 피해야 할 패턴이라는 의미로 안티패턴이라고 부르는 
사람도 있다. 


   
</details>

-----------------------
### 싱글톤 패턴의 한계는 무엇입니까?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: 토비의 스프링 p.106] 
   
+ + 자바에서 싱글톤을 구현하는 방법은 보통 이렇다. 
  - 클래스 밖에서는 오브젝트를 생성하지 못하도록 생성자를 private으로 만든다
  - 생성된 싱글톤 오브젝트를 저장할 수 있는 자신과 같은 타입의 스태틱 필드를 정의한다 
  - 스태틱 팩토리 메소드인 getInstance()를 만들고, 이 메소드가 최초로 호출되는 
     시점에서 한 번만 오브젝트가 만들어지게 한다. 
     생성된 오브젝트는 스태틱 필드에 저장된다.
     또는 스태틱 필드의 초기값으로 오브젝트를 미리 만들어둘 수도 있다
  - 한 번 오브젝트(싱글톤)가 만들어지고 난 후에는 getInstance()를 통해
    이미 만들어져 스태틱 필드에 저장해둔 오브젝트를 넘겨준다.

UserDao를 전형적인 싱글톤 패턴을 이용해 만든다면 리스트 1-22와 같이 될 것이다.

public class UserDao{
    private static UserDao INSTANCE;

   private UserDao(ConnectionMaker connectionMaker){
         this.connectionMaker = connectionMaker; 
   } 

   public static synchronized UserDao getInstance(){
        if(INSTANCE == null) INSTANCE = new UserDao(???);
        return INSTANCE;
   }

}

일단 깔끔하게 정리했던 UserDao에 싱글톤을 위한 코드가 추가되고 나니
코드가 상당히 지저분해졌다는 느낌이 든다.
게다가 private으로 바뀐 생성자는 외부에서 호출할 수가 없기 때문에
DaoFactory에서 UserDao를 생성하며 ConnectionMaker 오브젝트를 넣어주는게
이제는 불가능해졌다.
여러모로 생각해봐도 지금까지 깔끔하게 개선해온 UserDao에 싱글톤 패턴을 도입하는 건
무리로 보인다.
일반적으로 싱글톤 패턴 구현 방식에는 다음과 같은 문제가 있다

1) private 생성자를 갖고 있기 때문에 상속할 수 없다
- 싱글톤 패턴은 생성자를 private으로 제한한다.
  오직 싱글톤 클래스 자신만이 자기 오브젝트를 만들도록 제한하는 것이다.
  문제는 private 생성자를 가진 클래스는 다른 생성자가 없다면
  상속이 불가능하다는 점이다.
  객체지향의 장점인 상속과 이를 이용한 다형성을 적용할 수 없다.
  기술적인 서비스만 제공하는 경우라면 상관 없겠지만, 
  애플리케이션의 로직을 담고 있는 일반 오브젝트의 경우 싱글톤으로 만들었을 때,
  객체지향적인 설계의 장점을 적용하기가 어렵다는 점은 심각한 문제다.
  또한, 상속과 다형성 같은 객체지향의 특징이 적용되지 않는 스태틱 필드와 메소드를 사용하는 
  것도 역시 동일한 문제를 발생시킨다. 

2) 싱글톤은 테스트하기가 힘들다
- 싱글톤은 테스트하기가 어렵거나 테스트 방법에 따라 아예 테스트가 불가능하다.
  싱글톤은 만들어지는 방식이 제한적이기 때문에 테스트에서 사용될 때 목 오브젝트 등으로
  대체하기가 힘들다. 싱글톤은 초기화 과정에서 생성자 등을 통해 사용할 오브젝트를
  다이내믹하게 주입하기도 힘들기 때문에 필요한 오브젝트는 직접 오브젝트를 만들어
  사용할 수 밖에 없다. 이런 경우 테스트용 오브젝트로 대체하기가 힘들다.
  다음 장에서 살펴보겠지만 테스트는 엔터프라이즈 개발의 핵심인데
  애플리케이션 코드를 싱글톤으로 만들면 테스트를 만드는데 지장이 있다는 건 큰 단점이다. 

3) 서버 환경에서는 싱글톤이 하나만 만들어지는 것을 보장하지 못한다
- 서버에서 클래스 로더를 어떻게 구성하고 있느냐에 따라서 싱글톤 클래스임에도
   하나 이상의 오브젝트가 만들어질 수 있다.
   따라서 자바 언어를 이용한 싱글톤 패턴 기법은 서버환경에서는 싱글톤이 꼭 보장된다고 
   볼 수 없다. 
   여러 개의 JVM에 분산돼서 설치가 되는 경우에도 각각 독립적으로 오브젝트가 생기기 때문에
   싱글톤으로서의 가치가 떨어진다.

4) 싱글톤의 사용은 전역 상태를 만들 수 있기 때문에 바람직하지 못하다
- 싱글톤은 사용하는 클라이언트가 정해져 있지 않다. 싱글톤의 스태틱 메소드를 이용해
   언제든지 싱글톤에 쉽게 접근할 수 있기 때문에
   애플리케이션 어디서든지 사용될 수 있고, 그러다 보면 자연스럽게 전역 상태로 사용되기 쉽다.
   아무 객체나 자유롭게 접근하고 수정하고 공유할 수 있는 전역 상태를 갖는 것은
   객체지향 프로그래밍에서는 권장되지 않는 프로그래밍 모델이다.
   그럼에도 싱글톤을 사용하면 그런 유혹에 빠지기 쉽다.
   그럴 바에는 아예 스태틱 필드와 메소드로만 구성된 클래스를 사용하는 편이 낫다. 

   
</details>

-----------------------


### 싱글톤 레지스트리란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: 토비의 스프링 p.108]    
   
+ 
+ 스프링은 서버 환경에서 싱글톤이 만들어져서 서비스 오브젝트 방식으로 사용되는 것은
   적극 지지한다. 하지만 자바의 기본적인 싱글톤 패턴의 구현 방식은 여러 가지 단점이
   있기 때문에, 스프링은 직접 싱글톤 형태의 오브젝트를 만들고 관리하는 기능을 제공한다.
   그것이 바로 싱글톤 레지스트리다.

- 스프링 컨테이너는 싱글톤을 생성하고, 관리하고 공급하는 싱글톤 관리 컨테이너이기도 하다.
   싱글톤 레지스트리의 장점은 스태틱 메소드와 private 생성자를 사용해야 하는 비정상적인
   클래스가 아니라 평범한 자바 클래스를 싱글톤으로 활용하게 해준다는 점이다.

   평범한 자바 클래스라도 IoC 방식의 컨테이너를 사용해서 생성과 관계 설정, 사용 등에 대한 
    제어권을 컨테이너에게 넘기면 손쉽게 싱글톤 방식으로 만들어져 관리되게 할 수 있다.
    오브젝트 생성에 관한 모든 권한은 IoC 기능을 제공하는 애플리케이션 컨텍스트에 있기
    때문이다. 

 - 스프링의 싱글톤 레지스트리 덕분에 싱글톤 방식으로 사용될 애플리케이션 클래스라도
   public 생성자를 가질 수 있다. 싱글톤으로 사용돼야 하는 환경이 아니라면 간단히 오브젝트를
   생성해서 사용할 수 있다. 따라서 테스트 환경에서 자유롭게 오브젝트를 만들 수 있고,
   테스트를 위한 목 오브젝트로 대체하는 것도 간단하다. 
   DaoFactory에서 UserDao에 ConnectionMaker 오브젝트를 사용하도록 관계를 설정해주듯이,
   생성자 파라미터를 이용해서 사용할 오브젝트를 넣어주게 할 수도 있다. 

- 가장 중요한 것은 싱글톤 패턴과 달리 스프링이 지지하는 객체지향적인 설계 방식과 원칙,
   디자인 패턴(싱글톤 패턴은 제외)등을 적용하는데 아무런 제약이 없다는 점이다.
   스프링은 IoC 컨테이너일 뿐만 아니라, 고전적인 싱글톤 패턴을 대신해서 
   싱글톤을 만들고 관리해주는 싱글톤 레지스트리라는 점을 기억해두자.
   스프링이 빈을 싱글톤으로 만드는 것은 결국 오브젝트의 생성 방법을 제어하는 
    IoC 컨테이너로서의 역할이다.

- 앞에서 코드를 통해 확인해봤듯이, 이미 UserDao는 스프링 IoC를 적용하면서
   싱글톤으로 만들어진다. 그래서 getBean()을 여러 번 호출해서 UserDao를 요청하더라도
   매번 동일한 오브젝트를 받게 된다. 만약 스프링 없이 DaoFactory만 사용한다면
   이렇게 싱글톤 방식으로 UserDao를 한 번만 만들어두고 매번 같은 오브젝트를 리턴하게 하려면
   DaoFactory가 상당히 지저분해질 것이다.

</details>

-----------------------


### 싱글톤으로 만들어지기 때문에 주의해야 할 점은 무엇인가?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: 토비의 스프링 p.109]    
   
+ 
- 싱글톤은 멀티스레드 환경이라면 여러 스레드가 동시에 접근해서 사용할 수 있다
   따라서 상태 관리에 주의를 기울여야 한다.
   기본적으로 싱글톤이 멀티스레드 환경에서 서비스 형태의 오브젝트로 사용되는 경우에는
   상태 정보를 내부에 갖고 있지 않은 무상태(stateless) 방식으로 만들어져야 한다. 

- 다중 사용자의 요청을 한꺼번에 처리하는 스레드들이 동시에 싱글톤 오브젝트의 인스턴스
   변수를 수정하는 것은 매우 위험하다. 
   저장할 공간이 하나뿐이니 서로 값을 덮어쓰고 자신이 저장하지 않은 값을 읽어올 수 있기
   때문이다. 
  따라서 싱글톤은 기본적으로 인스턴스 필드의 값을 변경하고 유지하는 상태유지(stateful)
  방식으로 만들지 않는다. 이를 지키지 않으면 개발자 혼자서 개발하고 테스트할 때는 
   아무런 문제가 없겠지만, 서버에 배포되고 여러 사용자가 동시에 접속하면 데이터가 엉망이
   돼버리는 등의 심각한 문제가 발생할 것이다.
   물론 읽기전용의 값이라면 초기화 시점에서 인스턴스 변수에 저장해두고 
   공유하는 것은 아무 문제가 없다.


</details>

-----------------------

### POJO 프로그래밍이란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
   
+ IoC란 Inversion Of Control의 줄임말로, 프로그램의 제어권을 프레임워크가 가져가는 것을 의미합니다.  

[참고: 토비의 스프링 1권 p.732]

+ 
- 스프링의 목적은 애플리케이션 개발의 복잡합을 줄여주는 것 또는 효과적으로
  대응하게 해주는 것이라고 하면 맞는 말이긴 하지만 좀 추상적이다
   좀 더 기술적으로 스프링이 지향하는 목적이 무엇인지 정의해보자. 

- 스프링의 핵심 개발자들이 함께 쓴 'Professional Spring Framework'라는 책이 있다
   이 책에서 스프링 핵심 개발자들은 '스프링의 정수는 엔터프라이즈 서비스 기능을 POJO에
   제공하는 것'이라고 했다. 엔터프라이즈 서비스라고 하는 것은 보안, 트랜잭션과 같은 
   엔터프라이즈 시스템에서 요구되는 기술을 말한다.

- 이런 기술을 POJO에 제공한다는 말은, 뒤집어 생각해보면 엔터프라이즈 서비스 기술과
   POJO라는 애플리케이션 로직을 담은 코드를 분리했다는 뜻이기도 하다.
   '분리됐지만 반드시 필요한 엔터프라이즈 서비스 기술을 POJO 방식으로 개발된 
    애플리케이션 핵심 로직을 담은 코드에 제공한다'는 것이 스프링의 가장 강력한
    특징과 목표다. 

- 스프링의 핵심이 POJO 프로그래밍이라는 사실은 스프링의 핵심을 가장 나타내고 있다고
   알려진 그림 8-1의 스프링 삼각형을 통해서도 잘 알 수 있다.
   이 그림은 스프링 소스의 CTO인 아드리안 콜리어가 스프링의 핵심 개념을 설명하기 위해
   만들었다.

- 그림 8-1은 스프링으로 개발한 애플리케이션의 기본 구조를 보여준다.
   스프링 애플리케이션은 POJO를 이용해서 만든 애플리케이션 코드와,
   POJO가 어떻게 관계를 맺고 동작하는지를 정의해놓은 설계정보로 구분된다. 
   DI의 기본 아이디어는 유연하게 확장 가능한 오브젝트를 만들어두고,
   그 관계는 외부에서 다이내믹하게 설정해준다는 것이다.
   이런 DI의 개념을 애플리케이션 전반에 걸쳐 적용하는 것이
   스프링의 프로그래밍 모델이다.

- 스프링의 주요 기술인 IoC/DI, AOP와 PSA는 애플리케이션을 POJO로 개발할 수 있게 해주는
   가능 기술이라고 불린다.
   
</details>

-----------------------




