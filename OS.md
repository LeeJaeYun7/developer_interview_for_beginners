# OS

### 인터럽트란 무엇입니까?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+ 사용자 프로그램이 운영체제 서비스 수행 요청이 필요할 때, <br>
  운영체제에 보내는 요청을 인터럽트라고 합니다. <br>
  운영체제의 인터럽트 구동식 특성은 시스템의 일반적 구모를 정의하며, <br>
  각 타입의 인터럽트에 대해 어떠한 행동을 취해야 할지는 운영체제 내의 서로 다른 코드 세그먼트가 결정합니다. <br>
  한 인터럽트를 처리하기 위해 하나의 인터럽트 서비스 루틴이 제공됩니다. <br>  
   
</details>


-----------------------


### LRU 알고리즘이란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+ 페이지 교체 알고리즘의 한 종류로서, 가장 오랜 기간 사용되지 않은 페이지를 교체하는 알고리즘입니다. <br> 
   
</details>


-----------------------

### 프로세스와 스레드의 차이점은?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+ 프로세스는 실행중인 프로그램을 의미하며, 메모리를 할당 받은 프로그램을 의미합니다. <br>
  스레드는 프로세스의 하위 개념으로서, 하나의 프로세스는 다수의 실행 스레드를 가질 수 있으며, <br>
  실제 코드를 실행하는 단위입니다. 
  스레드는 프로세스보다 생성 비용이 저렴하며, 여러 스레드는 힙(heap)이라는 메모리 공간을 공유합니다. 
   
</details>


-----------------------


### 멀티 프로세스 대신 멀티 스레드를 사용하는 이유는?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+ 멀티 스레드 방식은 멀티 프로세스 방식에 비해 생성 비용(메모리 공간)이 저렴하며, context switch 비용이 적습니다. <br>
  또한 캐싱 측면에서도 스레드 모델의 성능이 더 좋습니다.  
   
   
</details>


-----------------------


### 멀티 프로세스 대신 멀티 스레드를 사용하는 이유는?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+ 멀티 스레드 방식은 멀티 프로세스 방식에 비해 생성 비용(메모리 공간)이 저렴하며, context switch 비용이 적습니다. <br>
  또한 캐싱 측면에서도 스레드 모델의 성능이 더 좋습니다.  
   
   
</details>


-----------------------


### 임계 구역(Critical Section)이란? 

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+ 임계 구역은 다른 프로세스와 공유하는 변수를 변경하거나, 테이블을 갱신하거나 파일을 쓰거나 하는 등의 작업을 수행하는 <br>
  영역을 의미합니다. <br> 
  이 때, 한 프로세스가 자신의 임계 구역에서 수행하는 동안에는 다른 프로세스들은 그들의 임계구역에 들어갈 수 없습니다. <br>
  즉, 동시에 두 프로세스가 그들의 임계구역 안에서 실행할 수 없습니다. 
   
</details>

-----------------------


### 스레드 안전(Thread safe)란 무엇입니까? 

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+ 멀티 스레드 프로그래밍에서 함수, 변수, 객체 등이 여러 스레드로부터 동시에 접근이 이루어져도, <br> 
  프로그램의 실행에 문제가 없음을 나타낸다. <br> 
   
   
</details>


-----------------------


### 스레드 안전한 코드를 작성하는 방법은 무엇입니까? 

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+ 1) Synchronized 함수 사용
  2) Synchronized 블록 사용
  3) ReentrantLock 사용
  4) 세마포어 사용 
  5) 모니터 사용 등이 있습니다. 
   
 <br> 
   
   
</details>


-----------------------

### Mutex Lock이란 무엇입니까? 

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+ Mutex Lock은 임계 구역을 보호하고 경쟁 조건을 방지하기 위해 사용되는 락을 의미합니다. <br>
  즉, 프로세스는 임계구역에 들어가기 전에 반드시 락을 획득해야 하고, <br>
  임계구역을 빠져 나올 때, 락을 반환해야 한다. <br> 
  acquire() 함수가 락을 획득하고, release() 함수가 락을 반환한다. <br>  
  acquire() 또는 relase() 함수 호출은 원자적으로 수행되어야 한다. <br>
  이 방식의 단점은 바쁜 대기(busy waiting)을 해야 한다는 것이다. <br>
  프로세스가 임계구역에 있는 동안 임계 구역에 들어가기 원하는 다른 프로세스들은 <br>
  acquire() 함수를 호출하는 반복문을 계속 실행해야 한다. <br>
  사실 이러한 유형의 mutex 락은 락이 가용해지기를 기다리면서 프로세스가 계속 회전을 하고 있기 때문에 <br>
  spinlock이라고도 부른다. 
   
</details>


-----------------------

### 세마포어란? 

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+ 세마포어는 mutex와 유사하게 동작하지만, 프로세스들이 자신들의 행동을 더 정교하게 동기화할 수 있는 방법을 제공하는 <br>
  강력한 도구입니다. <br> 
  세마포어는 리소스의 상태를 나타내는 일종의 카운터라고 할 수 있습니다. <br>  
   
  세마포 S는 정수 변수로서, 초기화를 제외하고는, 단지 두 개의 표준 원자적 연산 wait()와 signal()로만 접근이 가능힙니다. <br> 
  wait()와 signal() 연산 시 세마포의 정수 값을 변경하는 연산은 반드시 분리되지 않고 수행되어야 합니다. <br>
  즉, 한 스레드가 세마포 값을 변경하면, 다른 어떤 스레드도 동시에 동일한 세마포 값을 변경할 수 없습니다. 
   
 <br> 
   
   
</details>


-----------------------

### 세마포어의 종류에는 무엇이 있습니까? 

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+ 운영체제는 카운팅(counting)과 이진(binary) 세마포를 구분합니다. <br> 
  카운팅 세마포의 값은 제한 없는 영역(domain)을 갖습니다. <br>
  이진 세마포의 값은 0과 1사이의 값만 가능합니다. <br> 
   
 <br> 
   
   
</details>


-----------------------



### 시분할(또는 멀티 태스킹)이란 무엇입니까?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+ 다중 프로그래밍의 논리적 확장으로, 시분할 시스템에서는 CPU가 다수의 작업들을 교대로 수행하지만, <br>
  매우 빈번하게 교대가 일어나기 때문에 프로그램이 실행되는 동안에 사용자들은 각자 자기의 프로그램과 <br>
  상호 작용할 수 있다. 
</details>


-----------------------

### 프로세스란 무엇입니까?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+ 실행 중인 프로그램을 의미하며, 현대의 시분할 시스템에서 작업의 단위입니다. <br> 
  하나의 시스템은 프로세스들의 집합입니다. <br> 
</details>


-----------------------

### 프로세스의 상태란 무엇입니까? 무엇 무엇이 있습니까?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+ 프로세스 상태에는 새로운(new), 실행(running), 대기(waiting), 준비 완료(ready), 종료(terminated)가 있습니다. <br>
  새로운(new)은 프로세스가 생성 중임을 의미하고, <br>
  실행(running)은 명령어가 실행되고 있음을 의미하고, <br> 
  대기(waiting)는 프로세스가 어떤 사건(입출력 완료 또는 신호의 수신 등)이 일어나기를 기다리는 것을 의미하고, <br> 
  준비 완료(ready)는 프로세스가 처리기에 할당되기를 기다리는 것을 의미하며, <br>
  종료(terminated)는 프로세스의 실행이 종료되었음을 의미합니다. <br> 
</details>


-----------------------


### DeadLock이란 무엇입니까?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+  
</details>

-----------------------

### DeadLock이 성립하기 위한 4가지 조건은 무엇입니까?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+  
</details>

-----------------------

### DeadLock을 해결하기 위한 4가지 조건은 무엇입니까?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+  
</details>

-----------------------

### 메모리 관리 전략이란 무엇인가?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: 공룡책] 
   
+ 메모리 관리 알고리즘은 단순 하드웨어 방식에서 페이징과 세그먼트 방법까지 다양하며, <br>
  각 방법은 고유의 장,단점을 갖고 있습니다. <br> 
  
  가장 간단한 공간 할당 방법은 메모리를 똑같은 고정된 크기로 분할(partition)하는 것입니다. <br> 
  각 분할마다 한 프로세스를 가지고 이 때, 분할의 개수를 다중 프로그래밍 정도(multiprogramming degree)라고 합니다. <br>
  한 분할이 비게 되면 한 프로세스가 입력 큐(input queue)에서 선택되어 빈 분할에 들어옵니다. <br>
  그 프로세스가 끝나면 그 분할은 다른 프로세스를 위해 사용될 수 있습니다. <br>  
   
  가변 분할 기법에서 운영체제는 메모리의 어떤 부분이 사용되고 있고, 어떤 부분이 사용되지 않고 있는가를 파악할 수 있는 테이블을 유지합니다. <br> 
  초기에 모든 메모리 공간은 한 개의 큰 사용 가능한 블록으로 간주됩니다. <br> 
  이 경우 한 개의 공간(hole)이 있다고  표현합니다. <br> 
  앞으로 보겠지만 결국에는 메모리는 다양한 크기의 공간의 집합을 포함하게 됩니다.<br> 
   
   
</details>

-----------------------


### 동적 메모리 할당 문제에 대한 해결책은 무엇이 있는가?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: 공룡책] 
   
+ 최초 적합(First Fit), 최적 적합(Best Fit), 최악 적합(Worst Fit) 등이 있습니다. 
  
  1) 최초 적합(First Fit)
  - 첫 번째 사용 가능한 가용 공간을 할당합니다. 검색은 집합의 시작에서부터 하거나, <br>
    지난 번 검색이 끝났던 곳에서 시작될 수 있습니다. <br>
    충분히 큰 가용 공간을 찾았을 때, 검색을 끝낼 수 있습니다. <br> 
    
  2) 최적 적합(Best Fit)
  - 사용 가능한 공간들 중에서 가장 작은 것을 택합니다. 리스트가 크기 순으로 되어 있지 않다면 <br>
    전 리스트를 검색해야만 합니다. <br>
    이 방법은 아주 작은 가용 공간을 만들어냅니다. <br> 
   
  3) 최악 적합(Worst Fit)
  - 가장 큰 가용 공간을 택합니다. 이 방식을 할당해 주고 남게되는 자유 공간은 충분히 커서 <br>
    다른 프로세스들을 위하여 유용하게 사용될 수 있습니다. <br> 
    이 때, 자유 공간들이 크기 순으로 정렬되어 있지 않다면 전 리스트를 다 검색해야만 합니다. <br> 
   
   
</details>

-----------------------

### 가상 메모리란 무엇입니까?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+ 가상 메모리라는 것은 프로세스 전체가 메모리 내에 올라오지 않더라도 실행이 가능하도록 하는 기법입니다. <br> 
  이 기법의 주요 장점 중 하나는 사용자 프로그램이 물리 메모리보다 커져도 된다는 점입니다. <br> 
  가상 메모리는 물리 메모리로부터 사용자 관점의 논리 메모리를 분리시켜 메인 메모리를 균일한 크기의 저장 공간으로 구성된 <br>
  엄청나게 큰 배열로 추상화 시켜 줍니다. <br> 
  이 기법을 통해 프로그래머는 메모리의 크기 제약으로부터 자유로워집니다. 
   
[참고: incutv]    
+ 가상 메모리라는 것은 프로그램 전체가 아닌 필요한 일부분만 메모리에 올리는 기법입니다. <br> 
  즉, 가상 메모리는 프로세스의 물리 메모리와 논리 메모리를 분리하기 위해 생겨난 것입니다. 
  
  가상 메모리가 없는 경우를 생각하면, <br> 
  RAM의 메모리가 4GB라고 하고, 프로세스 A, B에 필요한 메모리가 4GB라고 한다면, <br> 
  메모리에 프로세스 A가 먼저 할당이 된다면, 프로세스 B는 할당할 메모리가 부족하여 사용할 수 없다. <br> 
   
  가상 메모리가 있는 경우는, 
  RAM의 메모리가 4GB라고 하고, 프로세스 A,B,C가 있다고 하면, <br> 
  프로세스가 현재 사용되는 메모리만큼만 물리 메모리(RAM)에 할당과 해제를 반복하여 <br>
  메모리를 사용한다면 여러 프로세스를 사용할 수 있다. <br> 
   
   
</details>

-----------------------


### 가상화란 무엇입니까?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+  
</details>

-----------------------

### 가상머신이란 무엇입니까?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+  
</details>

-----------------------

### 캐시의 지역성 원리란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+ 캐시 메모리는 속도가 빠른 장치와 느린 장치간의 속도차에 따른 병목 현상을 줄이기 위한 범용 메모리입니다. <br> 
  이러한 역할을 수행하기 위해서는 CPU가 어떤 데이터를 원할 것인가를 어느 정도 예측할 수 있어야 한다. 
   
  1) 캐시 메모리에서 원하는 데이터를 찾는 다면, 메인 메모리까지 가서 찾지 않아도 되기 때문에 성능 향상 <br> 
  2) 캐시 메모리에 원하는 데이터에 적중률 성능의 관건 <br> 
  -> 이 때, 적중률을 높이기 위해 데이터 지역성 원리를 사용한다. 
   
  시간 지역성 
  - 최근에 참조된 주소의 내용은 곧 다음에 다시 참조되는 특성 
   
  공간 지역성
  - 대부분의 실제 프로그램이 참조된 주소와 인접한 주소의 내용이 다시 참조되는 특성 
  -> 캐시 메모리에 데이터를 저장할 때, 공간 지역성을 최대한 활용하기 위해, 
     해당 데이터뿐만 아니라 옆 주소의 데이터도 같이 가져와 미래에 쓰일 것을 대비한다. 
 
   
</details>

-----------------------

