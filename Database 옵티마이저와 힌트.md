# 데이터베이스 옵티마이저와 힌트

<br>

### DBMS의 옵티마이저는 어떤 기능을 담당하는가?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: Real MySQL] 
  
+ MySQL 서버로 요청된 쿼리는 결과는 동일하지만, 내부적으로 그 결과를 만들어내는 방법은 매우 다양합니다. <br> 
  이런 다양한 방법 중에서 어떤 방법이 최적이고, 최소의 비용이 소모될지 결정해야 합니다. <br> 
  여행할 때도, 인터넷이나 책 등을 참고해서 최소한의 비용이 드는 방법을 알아본 뒤에 여행 경로를 결정합니다. <br> 
  
  MySQL에서도 쿼리를 최적으로 실행하기 위해 각 테이블의 데이터가 어떤 분포로 저장돼 있는지 통계 정보를 참조하며, <br> 
  그러한 기본 데이터를 비교해 최적의 실행 계획을 수립하는 작업이 필요합니다. <br> 
  MySQL 서버를 포함한 대부분의 DBMS에서는 옵티마이저가 이러한 기능을 담당합니다. <br> 
</details>

-----------------------

### MySQL에서는 EXPLAIN이라는 명령으로 무엇을 할 수 있는가?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: Real MySQL] 
  
+ 쿼리의 실행 계획을 확인할 수 있는데, EXPLAIN 명령의 결과에는 상당히 많은 정보가 출력됩니다. <br> 
  실행 계획에 표시되는 내용을 제대로 이해하려면 MySQL 서버 옵티마이저가 실행하는 최적화에 대해 어느 정도 지식을 갖추고 있어야 합니다. <br>
</details>

-----------------------

### MySQL에서 쿼리가 실행되는 과정은 크게 어떻게 나눌 수 있는가?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: Real MySQL] 
  
+ MySQL 서버에서 쿼리가 실행되는 과정은 크게 세 단계로 나눌 수 있습니다. <br> 
  1. 사용자로부터 요청된 SQL 문장을 잘개 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리(파스 트리)합니다. <br> 
  2. SQL의 파싱 정보(파스 트리)를 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택합니다. <br>
  3. 두 번째 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져옵니다. <br> 
  
  첫 번째 단계를 SQL 파싱(Parsing)이라고 하며, MySQL 서버의 'SQL 파서'라는 모듈로 처리합니다. <br> 
  SQL 문장이 문법적으로 잘못됐다면, 이 단계에서 걸러집니다. <br> 
  또한, 이 단계에서 'SQL 파스 트리'가 만들어집니다. <br> 
  MySQL 서버는 SQL 문장 그 자체가 아니라 SQL 파스 트리를 이용해 쿼리를 실행합니다. <br> 
  
  두 번째 단계는 첫 번째 단계에서 만들어진 SQL 파스 트리를 참조하면서 다음과 같은 내용을 처리합니다. <br> 
  - 불필요한 조건 제거 및 복잡한 연산을 단순화합니다. <br> 
  - 여러 테이블의 조인이 있는 경우 어떤 순서로 테이블을 읽을지 결정합니다. <br> 
  - 각 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스를 결정합니다. <br> 
  - 가져온 레코드들을 임시 테이블에 넣고 다시 한 번 가공해야 하는지 결정합니다. <br> 
  
  물론 이 밖에도 수많은 처리를 하지만 대표적으로 이러한 작업을 들 수 있습니다. <br>
  두 번째 단계는 "최적화 및 실행 계획 수립" 단계이며, MySQL 서버의 "옵티마이저"에서 처리합니다. <br> 
  또한 두 번째 단계가 완료되면 쿼리의 "실행 계획'이 만들어집니다. <br> 
  
  세 번째 단계는 수립된 실행 계획대로 스토리지 엔진에 레코드를 읽어오도록 요청하고, <br> 
  MySQL 엔진에서는 스토리지 엔진으로부터 받은 레코드를 조인하거나 정렬하는 작업을 수행합니다. <br> 
  첫 번째 단계와 두 번째 단계는 거의 MySQL 엔진에서 처리하며, <br>
  세 번째 단계는 MySQL 엔진과 스토리지 엔진이 동시에 참여해서 처리합니다. <br>  
  
</details>

-----------------------

### 옵티마이저의 종류에는 무엇이 있는가?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: Real MySQL] 
  
+ 옵티마이저는 데이터베이스 서버에서 두뇌와 같은 역할을 담당합니다. <br> 
  옵티마이저는 현재 대부분의 DBMS가 선택하고 있는 비용 기반 최적화(Cost-based optimizer, CBO) 방법과 <br>
  예전 초기 버전의 오라클 DBMS에서 많이 사용했던 규칙 기반 최적화 방법(Rule-based optimizer, RBO)으로 크게 나눌 수 있습니다. <br> 
  
  규칙 기반 최적화는 기본적으로 대상 테이블의 레코드 건수나 선택도 등을 고려하지 않고, <br> 
  옵티마이저에 내장된 우선순위에 따라 실행 계획을 수립하는 방식을 의미합니다. <br> 
  이 방식에서는 통계 정보(테이블의 레코드 건수나 칼럼값의 분포도)를 조사하지 않고, <br> 
  실행 계획이 수립되기 때문에 같은 쿼리에 대해서는 거의 항상 같은 실행 방법을 만들어 냅니다. <br>
  하지만 사용자의 데이터는 분포도가 매우 다양하기 때문에, 규칙 기반의 최적화는 이미 오래전부터 많은 DBMS에서는 거의 사용되지 않습니다. <br> 
   
  비용 기반 최적화는 쿼리를 처리하기 위한 여러 가지 가능한 방법을 만들고, 각 단위 작업의 비용(부하) 정보와 대상 테이블의 예측된 통계 정보 <br> 
  를 이용해 실행 계획별 비용을 산출합니다. <br>
  이렇게 산출된 실행 방법별로 비용이 최소로 소요되는 처리 방식을 선택해 최종적으로 쿼리를 실행합니다. <br> 
   
  규칙 기반 최적화는 각 테이블이나 인덱스의 통계 정보가 거의 없고, <br>
  상대적으로 느린 CPU 연산 탓에 비용 계산 과정이 부담스럽다는 이유로 사용되던 최적화 방법입니다. <br>
  현재는 대부분의 RDBMS가 비용 기반 옵티마이저를 채택하고 있으며, MySQL 역시 마찬가지입니다. <br> 
</details>

-----------------------

### 기본 데이터 처리에 있어서 풀 테이블 스캔과 풀 인덱스 스캔은 어떤 차이가 있는가?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: Real MySQL] 
  
+ 풀 테이블 스캔은 인덱스를 사용하지 않고 테이블의 데이터를 처음부터 끝까지 읽어서 요청된 작업을 처리하는 작업을 의미합니다. <br> 
  MySQL 옵티마이저는 다음과 같은 조건이 일치할 때, 주로 풀 테이블 스캔을 선택합니다. <br> 
  - 테이블의 레코드 건수가 너무 작아서 인덱스를 통해 읽는 것보다 풀 테이블 스캔을 하는 편이 더 빠른 경우(일반적으로 테이블이 페이지 1개로 구성된 경우) <br>
  - WHERE 절이나 ON절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우 <br> 
  - 인덱스 레인지 스캔을 사용할 수 있는 쿼리라고 하더라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우(인덱스의 B-Tree를 샘플링해서 조사한 통계 정보 기준) <br> 
   
  일반적으로 테이블의 전체 크기는 인덱스보다 훨씬 크기 때문에 테이블을 처음부터 끝까지 읽는 작업은 상당히 많은 디스크 읽기가 필요합니다. <br> 
  그래서 대부분 DBMS는 풀 테이블 스캔을 실행할 때 한꺼번에 여러 개의 블록이나 페이지를 읽어오는 기능을 내장하고 있습니다. <br> 
  하지만 MySQL에는 풀 테이블 스캔을 실행할 때, 한꺼번에 몇 개씩 페이지를 읽어올지 설정하는 시스템 변수는 없습니다. <br> 
  그래서 많은 사람들이 MySQL이 풀 테이블 스캔을 실행할 때, 디스크로부터 페이지를 하나씩 읽어 오는 것으로 생각합니다. <br> 
   
  이것은 MyISAM 스토리지 엔진에는 맞는 이야기지만, InnoDB에서는 틀린 말입니다. <br> 
  InnoDB 스토리지 엔진은 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 리드 어헤드(Read ahead) 작업이 자동으로 시작됩니다. <br> 
  리드 어헤드란 어떤 영역의 데이터가 앞으로 필요해지리라는 것을 예측해서 요청이 오기 전에 미리 디스크에서 읽어, <br> 
  InnoDB의 버퍼 풀에 가져다 두는 것을 의미합니다. <br> 
   
  즉, 풀 테이블 스캔이 실행되면 처음 몇 개의 데이터 페이지는 포그라운드 스레드(Foreground thread, 클라이언트 스레드)가 페이지 읽기를 실행하지만, <br> 
  특정 시점부터는 읽기 작업을 백그라운드 스레드로 넘깁니다. <br> 
  백그라운드 스레드가 읽기를 넘겨받는 시점부터는 한 번에 4개 또는 8개씩의 페이지를 읽으면서 계속 그 수를 증가시킵니다. <br> 
  이 때, 한 번에 최대 64개의 데이터 페이지까지 읽어서 버퍼 풀에 저장해줍니다. <br> 
  포그라운드 스레드는 미리 버퍼 풀에 준비된 데이터를 가져다 사용하기만 하면 되므로 쿼리가 상당히 빨리 처리되는 것입니다. <br> 
   
  MySQL 서버에서는 innodb_read_ahead_threshold 시스템 변수를 이용해 InnoDB 스토리지 엔진이 언제 리드 어헤드를 시작할지 임계값을 설정할 수 있습니다. <br> 
  포그라운드 스레드에 의해 innodb_read_ahead_threshold 시스템 변수에 설정된 개수만큼의 연속된 데이터 페이지가 읽히면, <br> 
  InnoDB 스토리지 엔진은 백그라운드 스레드를 이용해 대량으로 그 다음 페이지들을 읽어서 버퍼 풀로 적재합니다. <br> 
  일반적으로 디폴트 설정으로도 충분하지만, 데이터 웨어하우스용으로 MysQL을 사용한다면 이 옵션을 더 낮은 값으로 설정해서 <br> 
  더 빨리 리드 어헤드가 시작되게 유도하는 것도 좋은 방법입니다. <br> 
   
  리드 어헤드는 풀 테이블 스캔에서만 사용되는 것이 아니라 풀 인덱스 스캔에서도 동일하게 사용됩니다. <br> 
  풀 테이블 스캔이 테이블을 처음부터 끝까지 스캔하는 것을 의미하듯이, 풀 인덱스 스캔은 인덱스를 처음부터 끝까지 스캔하는 것을 의미합니다. <br> 
  예를 들어, 다음과 같은 쿼리를 한 번 생각해봅니다. <br> 
   
  ```
  mysql> SELECT COUNT(*) FROM employees;  
  ``` 
  
  이 쿼리는 아무런 조건 없이 employees 테이블의 레코드 건수를 조회하고 있으므로, 당연히 풀 테이블 스캔을 할 것처럼 보입니다. <br> 
  하지만 실제 실행 계획은 풀 테이블 스캔보다는 풀 인덱스 스캔을 하게 될 가능성이 높습니다. <br> 
  MySQL 서버는 앞의 예제와 같이 단순히 레코드의 건수만 필요로 하는쿼리라면 용량이 작은 인덱스를 선택하는 것이 디스크 읽기 횟수를 <br>
  줄일 수 있기 때문입니다. <br> 
   
  일반적으로 인덱스는 테이블의 2~3개 칼럼만으로 구성되기 때문에, 테이블 자체보다는 용량이 작아서 훨씬 빠른 처리가 가능합니다. <br> 
  하지만 다음과 같이 레코드에만 있는 칼럼이 필요한 쿼리의 경우에는 풀 인덱스 스캔을 활용하지 못하고 풀 테이블 스캔을 합니다. <br> 
   
  ```
  mysql> SELECT * FROM employees;  
  ``` 
  
</details>

-----------------------

### 병렬 처리란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: Real MySQL] 
  
+ MySQL 8.0버전부터는 용도가 한정돼 있긴 하지만, 처음으로 MySQL 서버에서도 쿼리의 병렬 처리가 가능해졌습니다. <br> 
  MySQL 8.0에서는 innodb_parallel_read_threads라는 시스템 변수를 이용해 하나의 쿼리를 최대 몇 개의 스레드를 이용해서 <br>
  처리할지를 변경할 수 있습니다. <br> 
  아직 MySQL 서버에서는 쿼리를 여러 개의 스레드를 이용해 병렬로 처리하게 하는 힌트나 옵션은 없습니다. <br> 
  MySQL 8.0 버전에서는 다음 예제와 같이 아무런 WHERE 조건 없이 단순히 테이블의 전체 건수를 가져오는 쿼리만 병렬로 처리할 수 있습니다. <br> 
  앞의 쿼리 실행 결과를 보면 병렬 처리용 스레드 개수가 늘어날수록 쿼리 처리에 걸리는 시간이 줄어드는 것을 확인할 수 있습니다. <br> 
  하지만 병렬 처리용 스레드 개수를 아무리 늘리더라도 서버에 장착된 CPU의 코어 개수를 넘어서는 경우에는 오히려 성능이 떨어질 수도 있으니 <br> 
  주의해야 합니다. <br>                                                                                      
</details>

-----------------------

### ORDER BY 처리(Using filesort)란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: Real MySQL] 
  
+ 레코드 1~2건을 가져오는 쿼리를 제외하면 대부분의 SELECT 쿼리에서 정렬은 필수적으로 사용됩니다. <br> 
  데이터 웨어하우스처럼 대량의 데이터를 조회해서 일괄 처리하는 기능이 아니라면, <br> 
  아마도 레코드 정렬 요건은 대부분의 조회 쿼리에 포함돼 있을 것입니다. <br> 
   
  정렬을 처리하는 방법은 인덱스를 이용하는 방법과 <br> 
  쿼리가 실행될 때 "Filesort"라는 별도의 처리를 이용하는 방법으로 나눌 수 있습니다. <br> 
   
  인덱스를 이용하는 방법의 장점은 <br>
  INSERT, UPDATE, DELETE 쿼리가 실행될 때 이미 인덱스가 정렬돼 있어서 순서대로 읽기만 하면 되므로 매우 빠르다는 것입니다. <br> 
  반면, 단점은 INSERT, UPDATE, DELETE 작업 시부가적인 인덱스 추가/삭제 작업이 필요하므로 느리다는 것입니다. <br> 
  인덱스 때문에 디스크 공간이더  많이 필요합니다. <br> 
  인덱스의 개수가 늘어날수록 InnoDB의 버퍼 풀을 위한 메모리가 많이 필요합니다. <br> 
   
  Filesort를 이용하는 방법의 장점은 <br>
  인덱스를 생성하지 않아도 되므로, 인덱스를 이용할 때의 단점이 장점으로 바뀝니다. <br> 
  정렬해야 할 레코드가 많지 않으면 메모리에서 FileSort가 처리되므로 충분히 빠릅니다. <br> 
  반면, 단점은 정렬 작업이 쿼리 실행 시 처리되므로 레코드 대상 건수가 많아질수록 쿼리의 응답 속도가 느리다는 점입니다. <br> 
   
  물론 레코드를 정렬하기 위해 항상 Filesort라는 정렬 작업을 거쳐야 하는 것은 아닙니다. <br> 
  이미 인덱스를 이용한 정렬은 8.3.6절 'B-TREE 인덱스의 정렬 및 스캔 방향'에서 한 번 살펴봤습니다. <br>   
  하지만 다음과 같은 이유로 모든 정렬을 인덱스를 이용하도록 튜닝하기란 거의 불가능합니다. <br> 
   
  - 정렬 기준이 너무 많아서 요건별로 모두 인덱스를 생성하는 것이 불가능한 경우 <br>  
  - GROUP BY의 결과 또는 DISTINCT 같은 처리의 결과를 정렬해야 하는 경우 <br> 
  - UNION의 결과와 같이 임시 테이블의 결과를 다시 정렬해야 하는 경우 <br> 
  - 랜덤하게 결과 레코드를 가져와야 하는 경우 <br> 
   
   
</details>

-----------------------

### 소트 버퍼란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: Real MySQL] 
  
+ MySQL은 정렬을 수행하기 위해 별도의 메모리 공간을 할당 받아서 사용하는데, <br> 
  이 메모리 공간을 소트 버퍼(sort buffer)라고 합니다. <br> 
  소트 버퍼는 정렬이 필요한 경우에만 할당되며, 버퍼의 크기는 정렬해야 할 레코드의 크기에 따라 가변적으로 증가하지만, <br> 
  최대 사용 가능한 소트 버퍼의 공간은 sort_buffer_size라는 시스템 변수로 설정할 수 있다. <br> 
  소트 버퍼를 위한 메모리 공간은 쿼리의 실행이 완료되면 즉시 시스템으로 반납된다. <br> 
   
  여기까지는 아주 이상적인 부분만 이야기했는데, 지금부터 정렬이 왜 문제가 되는지 살펴보자. <br> 
  정렬해야 할 레코드가 아주 소량이어서 메모리에 할당된 소트 버퍼만으로 정렬할 수 있다면 <br> 
  아주 빠르게 정렬이 처리될 것입니다. <br> 
  하지만 정렬해야 할 레코드의 건수가 소트 버퍼로 할당된 공간보다 크다면 어떨까? <br> 
  이 때, MySQL은 정렬해야 할 레코드를 여러 조각으로 나눠서 처리하는데, 이 과정에서 임시 저장을 위해 디스크를 사용한다. <br> 
    
</details>

-----------------------

### MySQL의 정렬 알고리즘이란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: Real MySQL] 
  
+ 레코드를 정렬할 때, 레코드 전체를 소트 버퍼에 담을지 또는 정렬 기준 칼럼만 소트 버퍼에 담을지에 따라 <br> 
  싱글 패스 와 투 패스 2가지 정렬 모드로 나눌 수 있습니다. <br> 
  정렬을 수행하는 쿼리가 어떤 정렬 모드를 사용하는지는 다음과 같이 옵티마이저 트레이스 기능으로 확인할 수 있습니다. <br> 
</details>

-----------------------

### 싱글 패스 정렬 방식이란 무엇가?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: Real MySQL] 
  
+ 소트버퍼에 정렬 기준 칼럼을 포함해 SELECT 대상이 되는 칼럼 전부를 담아서 정렬을 수행하는 정렬 방식입니다. <br> 
  
</details>

-----------------------

### 투 패스 정렬 방식이란 무엇가?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: Real MySQL] 
  
+ 정렬 대상 칼럼과 프라이머리 키 값만 소트 버퍼에 담아서 정렬을 수행하고, 정렬된 순서대로 다시 프라이머리 키로 테이블을 읽어서 <br>
  SELECT할 칼럼을 가져오는 정렬 방식으로, 싱글 패스 정렬 방식이 도입되기 이전부터 사용하던 방식입니다. <br> 
  하지만 MySQL 8.0에서도 여전히 특정 조건에서는 투 패스(Two-pass) 정렬 방식을 사용합니다. <br> 
  
</details>

-----------------------
