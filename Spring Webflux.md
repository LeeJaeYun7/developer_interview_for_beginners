# Spring Webflux
<br>


### 리액터란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: 스프링 인 액션]    

+ 신문이나 잡지를 구독해본 적이 있는가? 인터넷으로 인해 기존 출판물의 구독자가 줄어든 것은 분명하다. <br> 
  그러나 종이에 인쇄된 신문 구독이 그 날의 소식을 알 수 있는 가장 좋은 방법 중 하나였던 시절이 있었습니다. <br> 
  이 때는 아침을 먹으면서 또는 출근길에 읽기 위해 최신 소식을 담은 신문의 배달을 매일 아침에 기다리곤 했습니다. <br> 
  
  구독료를 지불하고 며칠이 지났지만 신문이 배달되지 않는다고 가정해 봅니다. <br> 
  며칠이 더 지난 후에 신문사 영업소에 전화해서 신문을 받지 못한 이유를 묻습니다. <br> 
  이 때, "1년치 구독료를 내셨군요. 아직 1년이 끝나지 않았습니다. 1년 동안의 신문이 모두 준비되면 한꺼번에 받으실겁니다" <br> 
  라는 황당한 답변을 듣는다면 얼마나 놀라울지 상상해 봅니다. <br> 
  
  다행히도 이런 식으로 신문 구독이 처리되지는 않습니다. 신문에 실린 기사가 최신일 때, 독자가 읽을 수 있도록 신문은 출간 후 <br> 
  가능한 빨리 배달됩니다. 또한, 독자가 가장 최근 기사를 읽는 동안 신문 기자는 다음 판에 실을 새로운 기사를 작성합니다. <br> 
  그리고 신문사는 다음 판의 출간을 서두릅니다. <br> 
  이 모든 것은 병행으로 진행됩니다. <br> 
  
  애플리케이션 코드를 개발할 때는, 명령형(imperative)와 리액티브(reactive)의 두 가지 형태로 코드를 작성할 수 있습니다. <br> 
  
  명령형 코드는 앞에서 상상했던 황당하며 실제가 아닌 신문 구독과 매우 유사합니다. <br> 
  이것은 순차적으로 연속되는 작업이며, 각 작업은 한 번에 하나씩 그리고 이전 작업 다음에 실행됩니다. <br> 
  데이터는 모아서 처리되고, 이전 작업이 데이터 처리를 끝낸 후에 다음 작업으로 넘어갈 수 있습니다. <br> 
  
  리액티브 코드는 실제 신문 구독과 매우 비슷합니다. 데이터 처리를 위해 일련의 작업들이 정의되지만, <br> 
  이 작업들은 병렬로 실행될 수 있습니다. 그리고 각 작업은 부분 집합의 데이터를 처리할 수 있으며, <br> 
  처리가 끝난 데이터를 다음 작업에 넘겨주고 다른 부분 집합의 데이터로 계속 작업할 수 있습니다. <br> 
  
  이번 장에서는 잠시 타코 클라우드 애플리케이션을 접어 두고, 프로젝트 리액터를 살펴볼 것입니다. <br> 
  리액터는 스프링 프로젝트의 일부분인 리액티브 프로그래밍 라이브러리입니다. <br> 
  그리고 리액터는 스프링 5에서 리액티브 프로그래밍을 지원하는 데 필요한 기반이므로, <br> 
  먼저 리액터를 파악한 다음에 스프링으로 리액티브 컨트롤러와 리퍼지터리를 빌드하는 것이 중요합니다. <br> 
  
   
</details>

-----------------------

### 리액티브 프로그래밍이란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: 스프링 인 액션]    

+ 리액티브 프로그래밍은 명령형 프로그래밍의 대안이 되는 패러다임입니다. <br> 
  명령형 프로그래밍의 한계를 해결할 수 있기 때문입니다. <br> 
  이런 한계를 이해하면 리액티브 모델의 장점을 더 확실하게 이해할 수 있습니다. <br> 
  
  여러분이 필자와 같은 개발자라면 명령형 프로그래밍을 먼저 경험했을 것입니다. <br> 
  실제로 현재 우리가 작성하는 대부분의 코드는 여전히 명령형일 가능성이 높습니다. <br> 
  명령형 프로그래밍은 학생들이 학교에서 프로그래밍을 배우기 쉬우며, <br> 
  기업에 필요한 대부분의 코드를 구성할 만큼 강력합니다. <br> 
  
  명령형 프로그래밍의 발상은 간단합니다. 즉, 한 번에 하나씩 만나는 순서대로 실행되는 명령어들로 코드를 작성하면 됩니다. <br> 
  그리고 프로그램에서는 하나의 작업이 완전히 끝나기를 기다렸다가, 그 다음 작업을 수행합니다. <br> 
  각 단계마다 처리되는 데이터는 전체를 처리할 수 있도록 사용할 수 있어야 합니다. <br> 
  
  그러나 작업이 수행되는 동안 특히 이 작업이 원격지 서버로부터 데이터베이스에 데이터를 쓰거나 가져오는 것과 같은 것이라면 <br> 
  이 작업이 완료될때까지 아무것도 할 수 없습니다. <br> 
  따라서 이 작업을 수행하는 스레드는 차단됩니다. <br> 
  이렇게 차단되는 스레드는 낭비입니다. <br> 
  
  자바를 비롯해서 대부분의 프로그래밍 언어는 동시 프로그래밍을 지원합니다. <br> 
  자바에서는 스레드가 어떤 작업을 계속 수행하는 동안 이 스레드에서 다른 스레드를 시작시키고 작업을 수행하게 하는 것은 매우 쉽습니다. <br> 
  그러나 스레드를 생성하는 것은 쉬울지라도 생성된 스레드는 어떤 이유로든 결국 차단됩니다. <br> 
  게다가 다중 스레드로 동시성을 관리하는 것은 쉽지 않습니다. <br> 
  스레드가 많을수록 더 복잡해지기 때문입니다. <br> 
  
  이에 반해 리액티브 프로그래밍은 본질적으로 함수적이면서 선언적입니다. 즉, 순차적으로 수행되는 작업 단계를 나타낸 것이 아니라, <br> 
  데이터가 흘러가는 파이프라인이나 스트림을 포함합니다. <br> 
  그리고 이런 리액티브 스트림은 데이터 전체를 사용할 수 있을 때까지 기다리지 않고 사용 가능한 데이터가 있을 때마다 처리되므로 <br> 
  사실상 입력되는 데이터는 무한할 수 있습니다. (예를 들어, 끊임없이 변동되는 어떤 지역의 실시간 온도 데이터) 
  
  실세계에 비유한다면 명령형 프로그래밍은 물풍선이고, 리액티브 프로그래밍은 정원용 호스로 생각할 수 있습니다. <br> 
  둘 다 무더운 여름날에 낌새를 못 채는 친구를 깜짝 놀라게 하고 물세례를 하는데 사용할 수 있습니다. <br> 
  그러나 실행 방식은 다릅니다. <br> 
  
  물풍선은 한 번에 모든 물을 담았다가 충격이 가해지는 순간 의도한 목표를 물로 흠뻑 적십니다. <br> 
  그러나 물풍선은 한정된 용량을 가지므로, 더 많은 사람들에게 물세례를 퍼부으려면 물풍선의 수량을 늘려서 용량을 확장하는 수 밖에 없습니다. <br> 
  
  정원용 호스는 수도꼭지로부터 분무기 노즐로 흐르는 물줄기로 물을 전달합니다. <br> 
  특정 시점에서 정원용 호스의 용량은 한정될 수 있습니다. 그러나 물을 계속 트는 동안에는 무한정입니다. <br> 
  수도꼭지로부터 호스로 물이 흐르기만 한다면 호스를 거쳐 분무기 노즐로 계속 살포될 것입니다. <br> 
  정원용 호스는 쉽게 확장될 수 있어서 가능한 많은 친구들에게 물세례를 줄 수 있습니다. <br> 
  
  본질적으로 물풍선은 잘못한 부분이 없습니다. <br> 
  그러나 정원용 호스를 잡고 있는 사람은 확장성과 성능 관점에서 유리합니다. 
  
     
</details>


-----------------------
