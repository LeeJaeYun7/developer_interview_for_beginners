# JPA
<br>


### 엔티티 매니저란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
 
[참고: 자바 ORM 표준 JPA 프로그래밍] 
 
+ 엔티티 매니저는 엔티티를 저장하고, 수정하고, 삭제하고, 조회하는 등 엔티티와 관련된 모든 일을 처리합니다. <br> 
  이름 그대로 엔티티를 관리하는 관리자입니다. <br> 
  개발자 입장에서 엔티티 매니저는 엔티티를 저장하는 가상의 데이터베이스로 생각하면 됩니다. <br> 
   
   
</details>


-----------------------


### 영속성 컨텍스트란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+ 엔티티를 영구히 저장하는 환경을 의미합니다. <br>
  엔티티 매니저로 엔티티를 저장하거나 조회하면 <br>
  엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리합니다. <br> 
   
[참고: 자바 ORM 표준 JPA 프로그래밍] 
 
+ JPA를 이해하는 데 가장 중요한 용어는 영속성 컨텍스트입니다. <br> 
  우리말로 번역하기가 어렵지만 해석하자면 '엔티티를 영구 저장하는 환경'이라는 뜻입니다. <br> 
  엔티티 매니저로 엔티티를 저장하거나 조회하면, <br> 
  엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리합니다. <br> 
   
</details>


-----------------------

### 엔티티의 생명주기란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+ 엔티티에는 4가지 상태가 존재하는데, 그것은 비영속, 영속, 준영속, 삭제입니다. <br> 
  비영속은 영속성 컨텍스트와 전혀 관계가 없는 상태를 의미하고, <br>
  영속은 영속성 컨텍스트에 저장된 상태, <br>
  준영속은 영속성 컨텍스트에 저장되었다가 분리된 상태, <br>
  삭제는 삭제된 상태를 의미합니다. <br> 
   
[참고: 자바 ORM 표준 JPA 프로그래밍] 
 
 + 엔티티에는 4가지 상태가 존재합니다. <br> 
   비영속: 영속성 컨텍스트와 전혀 관계가 없는 상태 <br>
   영속: 영속성 컨텍스트에 저장된 상태 <br> 
   준영속: 영속성 컨텍스트에 저장되었다가 분리된 상태 <br> 
   삭제: 삭제된 상태 
   
</details>

-----------------------

### 영속성 컨텍스트의 1차 캐시란 무엇인가?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+ 영속 상태의 엔티티가 저장되는 공간을 의미합니다. <br> 
  영속성 컨텍스트 내부에 Map이 하나 있는데, 키는 @Id로 매핑한 식별자고, <br>
  값은 엔티티 인스턴스입니다. <br> 
  만약 찾는 엔티티가 있으면 데이터베이스를 조회하지 않고 메모리에 있는 1차 캐시에서 엔티티를 조회합니다. <br>  
   
[참고: 자바 ORM 표준 JPA 프로그래밍] 

+ 영속성 컨텍스트는 내부에 캐시를 가지고 있는데, 이것을 1차 캐시라고 합니다. <br> 
  영속 상태의 엔티티는 모두 이곳에 저장됩니다. <br> 
  쉽게 이야기하면 영속성 컨텍스트 내부에 Map이 하나 있는데 키는 @Id로 매핑한 식별자고 값은 인스턴스입니다. 
   
</details>

-----------------------


### 변경 감지(dirty checking)란 무엇인가?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+ 변경 사항을 데이터베이스에 자동으로 반영하는 기능입니다. <br> 
   
   
[참고: 자바 ORM 표준 JPA 프로그래밍] 

+ JPA로 엔티티를 수정할 때는 단순히 엔티티를 조회해서 데이터만 변경하면 됩니다. <br> 
  트랜잭션 커밋 직전에 주석으로 처리된 em.update() 메소드를 실행해야 할 것 같지만, <br> 
  이런 메소드는 없습니다. <br> 
   
  이렇게 엔티티의 변경사항을 데이터베이스에 자동으로 반영하는 기능을 <br>
  변경 감지(dirty checking)이라고 합니다. 
   
  JPA는 엔티티를 영속성 컨텍스트에 보관할 때, 최초 상태를 복사해서 저장해두는데 이것을 스냅샷이라고 합니다. <br> 
  그리고 플러시 시점에 스냅샷과 엔티티를 비교해서 변경된 엔티티를 찾습니다. <br> 
  
  1) 트랜잭션을 커밋하면 엔티티 매니저 내부에서 먼저 플러시가 호출됩니다. <br> 
  2) 엔티티와 스냅샷을 비교해서 변경된 엔티티를 찾습니다. <br> 
  3) 변경된 엔티티가 있으면 수정 쿼리를 생성해서 쓰기 지연 SQL 저장소에 보냅니다. <br> 
  4) 쓰기 지연 저장소의 SQL을 데이터베이스에 보냅니다. <br> 
  5) 데이터베이스 트랜잭션을 커밋합니다. <br> 
   
  변경 감지는 영속성 컨텍스트가 관리하는 영속 상태의 엔티티에만 적용됩니다. <br> 
  비영속, 준영속처럼 영속성 컨텍스트의 관리를 받지 못하는 엔티티는 값을 변경해도 데이터베이스에 반영되지 않습니다. 
</details>

-----------------------


### 플러시란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
   
[참고: 자바 ORM 표준 JPA 프로그래밍] 

+ 플러시는 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영합니다. <br> 
  플러시를 실행하면 구체적으로 다음과 같은 일이 일어납니다. <br> 
   
  1) 변경 감지가 동작해서 영속성 컨텍스트에 있는 모든 엔티티를 스냅샷과 비교해서 수정된 엔티티를 찾습니다. <br> 
     수정된 엔티티는 수정 쿼리를 만들어 쓰기 지연 SQL 저장소에 등록합니다. <br> 
  2) 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송합니다. (등록, 수정, 삭제 쿼리) 
</details>

-----------------------

### @Column이란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+ 객체 필드를 테이블 칼럼에 매핑하는데 사용됩니다. 
</details>


-----------------------

### @Column의 name이란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+ name은 필드와 매핑할 테이블의 컬럼 이름을 의미합니다. 
</details>


-----------------------

### @ManyToOne이란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+ 이름 그대로 다대일(N:1) 관계라는 매핑 정보입니다.  
</details>

-----------------------

### @JoinColumn이란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+ 조인 칼럼은 외래 키를 매핑할 때 사용합니다. <br>    
  name은 매핑할 외래 키 이름을 의미합니다. 
</details>

-----------------------

### mappedBy란 무엇인가?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+ 두 객체 연관관계 중 하나를 정해서 테이블의 외래키를 관리해야 하는데, <br>
  이것을 연관관계의 주인이라고 합니다. <br>
  양방향 연관관계 매핑 시, 두 연관관계 중 하나를 연관관계의 주인으로 정해야 합니다. <br> 
  주인은 mappedBy 속성을 사용하지 않고, <br>
  주인이 아니면 mappedBy 속성을 사용해서 속성의 값으로 연관관계의 주인을 지정해야 합니다. <br> 
</details>

-----------------------



