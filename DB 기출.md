# DB 기출
<br>

### 정규화란 무엇입니까?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

[참고: 데이터베이스 개론 p.330]

+ 8장에서는 관계 데이터 모델에 기반을 두고 데이터베이스를 설계하는 방법 중 
E-R 모델과 릴레이션 변환 규칙을 이용하는 방법을 살펴보았다

이 장에서는 정규화를 이용해 데이터베이스를 설계하는 방법에 대해 소개한다
정규화는 데이터베이스를 설계한 후 설계 결과물을 검증하기 위해 사용하기도 한다
앞에서도 언급했듯이, 두 설계 방법은 데이터베이스 설계 결과물이 비슷한 수준을
유지하므로 상황에 따라 적절한 방법을 선택하면 된다

데이터베이스를 잘못 설계하면 불필요한 데이터 중복이 발생하여 릴레이션에 대한 데이터의 삽입, 수정, 삭제 연산을 수행할 때 부작용이 발생할 수 있다. 이러한 부작용을 이상 현상이라 한다
이상 현상을 제거하면서 데이터베이스를 올바르게 설계해나가는 과정이 정규화다
정규화의 필요성과 방법을 구체적으로 알아보기에 앞서 먼저 이상 현상을 종류별로 자세히 알아보자
</details>

-----------------------

### 이상 현상이란 무엇입니까?

<details>
   <summary> 답안 보기 (👈 Click)</summary>

[참고: 데이터베이스 개론 p.330]

+ 
1) 이상 현상의 종류
- 이상 현상에는 [그림 9-1]과 같이 삽입 이상, 갱신 이상, 삭제 이상이 있다
   삽입 이상 - 새 데이터를 삽입하기 위해 불필요한 데이터도 함께 삽입해야 하는 문제
   갱신 이상 - 중복 투플 중 일부만 변경하여 데이터가 불일치하게 되는 모순의 문제
   삭제 이상 - 투플을 삭제하면 꼭 필요한 데이터까지 함께 삭제되는 데이터 손실의 문제

 [그림 9-2]의 이벤트 참여 릴레이션을 이용해 잘못 설계된 릴레이션에서 발생할 수 있는
 이상 현상을 살펴보고, 이를 통해 이상 현상의 개념을 이해해보자. 

[그림 9-2]의 이벤트참여 릴레이션은 고객들이 이벤트에 참여한 결과를 저장하고 있는 릴레이션이다. 고객에 대한 정보인 고객아이디, 고객이름, 등급과 고객이 참여한 이벤트에 대한 정보인 이벤트번호, 당첨여부를 포함하고 있다. 
한 고객이 여러 이벤트에 참여할 수 있으므로 고객아이디만으로는 투플을 유일하게 식별할 수 없다.
그러므로 고객아이디와 이벤트번호 속성을 함께 사용하여 이벤트참여 릴레이션의 기본키를 구성한다. 

고객 한 명이 여러 이벤트에 참여할 수 있으므로 이벤트참여 릴레이션에는 동일한 고객의 
이름과 등급이 여러 번 나타날 수 있다.
예를 들어, 아이디가 apple인 고객은 3개의 이벤트에 참여하므로
고객의 이름과 등급이 이벤트참여 릴레이션에 세 번 저장된다.
이렇게 동일한 데이터가 여러 번 중복되어 저장되면 저장 공간을 낭비할 뿐 아니라
릴레이션에 데이터를 삽입, 수정,삭제 할 때 삽입,갱신, 삭제 이상 현상이 발생할 수 있다 

1)삽입 이상
- 릴레이션에 새 데이터를 삽입하기 위해 원치 않는 불필요한 데이터도 함께 삽입해야 하는 문제를 삽입 이상이라 한다
  예를 들어, 아이디가 melon이고, 이름이 성원용, 등급이 gold인 신규 고객이 회원으로 가입하여, [그림 9-2]의 이벤트참여 릴레이션에 이 고객에 대한 데이터를 삽입해야 한다고 해보자.
  이 고객이 참여한 이벤트가 아직 업삳면 이벤트참여 릴레이션에 이 고객에 대한 데이터를 삽입할 수 없다. 이벤트참여 릴레이션의 기본키가 고객아이디와 이벤트번호 속성이고,
  기본키를 구성하는 속성은 널 값을 가질 수 없다는 제약이 존재하기 때문이다. 
  즉, 고객아이디와 참여한 이벤트번호가 모두 존재해야 이벤트참여 릴레이션에 새 고객의 데이터를 삽입할 수 있다. 따라서 성원용 고객에 대한 데이터를 이벤트참여 릴레이션에 삽입하려면 실제로 참여하지 않은 임시 이벤트번호를 삽입해야 하므로 이벤트참여 릴레이션에는 삽입 이상이 발생하게 된다. 

2) 갱신 이상
- 릴레이션의 중복된 투플들 중 일부만 수저앟여 데이터가 불일치하게 되는 모순이 발생하는 것을 
   갱신 이상이라한다. [그림9-2]의 이벤트참여 릴레이션에는 아이디가 apple인 고객에 대한 
   투플이 3개 존재하여, 고객아이디, 고객이름, 등급 속성의 값이 중복되어 있다. 
   아이디가 apple인 고객의 등급이 gold에서 vip로 변경된다면, 이벤트참여 릴레이션에서 
   apple 고객에 대한 투플 3개의 등급 속성 값이 모두 수정되어야 한다. 
   그렇지 않고 [그림9-2]와 같이 2개의 투플만 등급이 수정되면 apple 고객이 서로 다른 등급을 가지는 모순이 생겨 갱신 이상이 발생하게 된다 

3) 삭제 이상
- 릴레이션에서 투플을 삭제하면 꼭 필요한 데이터까지 함께 삭제하여 데이터가  손실되는 
  연쇄 삭제 현상을 삭제 이상이라 한다. 

아이디가 orange인 고객이 이벤트 참여를 취소하여 [그림 9-2]의 이벤트참여 릴레이션에서 관련된 투플을 삭제해야 한다면, [그림 9-5]와 같이 하나의 투플만 삭제하면 된다.
그런데 이 투플은 아이디가 orange인 고객이 참여하고 있는 이벤트에 대한 정보만 가지고 있는 것이 아니라, 해당 고객에 대한 정보인 고객아이디, 고객이름, 등급에 대한 정보도 유일하게 가지고 있다. 
따라서 이 투플이 삭제되면 이벤트 참여와 관련이 없음에도 불구하고 해당 고객에 대한 고객아이디, 고객이름, 등급 데이터까지 원치 않게 손실되는 삭제 이상이 발생하게 된다. 

[그림 9-2]의 이벤트참여 릴레이션에 여러 이상 현상이 발생하는 이유는 무엇일까?
관련이 없는 데이터, 즉 관련 없는 속성들을 하나의 릴레이션에 모아 두고 있기 때문이다.
이상 현상이 발생하지 않도록 하려면, 관련 있는 속성들로만 릴레이션을 구성해야 하는데,
이를 위해 필요한 것이 정규화다.

정규화는 이상 현상이 발생하지 않도록, 릴레이션을 관련이 있는 속성들로만 구성하기 위해 릴레이션을 분해하는 과정이다. 정규화를 통해 릴레이션 설계를 올바르게 완성할 수 있다. 

정규화를 수행하려면 먼저 릴레이션을 구성하는 속성들 간의 관련성을 판단할 수 있어야 한다.
정규화 과정에서 고려해야 하는 속성들 간의 관련성을 함수적 종속성이라고 한다.

일반적으로 릴레이션에 함수적 종속성이 하나 존재하도록 정규화를 통해 릴레이션을 분해한다.
그러므로 정규화를 본격적으로 살펴보기에 앞서 다음 절에서 함수적 종속성의 의미와 
함수적 종속성을 판단하는 방법부터 알아보자. 



</details>

-----------------------

### 함수 종속이란 무엇입니까?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

[참고: 데이터베이스 개론 p.335]

+ 하나의 릴레이션을 구성하는 속성들읠 부분 집합을 X와 Y라 할 때,
어느 시점에서든 릴레이션 내의 모든 투플에서 X값에 대한 Y값이 항상 하나면
"X가 Y를 함수적으로 결정한다" 또는 "Y가 X에 함수적으로 종속되어 있다"라고 한다

함수 종속 관계는 X->Y로 표현하고, X를 결정자, Y를 종속자라고 한다

[그림 9-7]의 고객 릴레이션을 대상으로 속성 간의 함수 종속 관계를 판단해보자.

[그림 9-7]의 고객 릴레이션에서 각 고객아이디 속성 값에 대응되는 고객이름 속성과
등급 속성의 값이 단 하나이므로, 고객 아이디가 고객이름과 등급을 결정한다고 볼 수 있다.
예를 들어, 고객아이디가 apple인 고객은 이름이 정소화, 등급이 gold인 한 사람박에 없다.
그러므로 고객 릴레이션에서 고객이름과 등급 속성은 고객아이디 속성에 함수적으로 종속되어 있어,
고객아이디는 결정자가 되고 고객이름과 등급은 종속자가 된다. 

고객 릴레이션에 존재하는 함수 종속 관계는 다음과 같이 기호로 표현할 수 있다
하나의 릴레이션을 구성하는 속성들 간의 함수 종속 관계를 도식화하여 표현할 수 있다
이를 함수 종속 다이어그램이라고 하는데, 함수 종속 다이어그램은 복잡한 함수 종속 관계를 더 직관적으로 이해하는 데 도움이 된다.
예로 제시한 고객 릴레이션의 함수 종속 다이어그램은 [그림 9-9]와 같다 

함수 종속 관계를 판단할 때 유의할 점은, 현재 시점에 릴레이션에 포함된 속성 값만으로 판단하면 안된다는 것이다. 릴레이션에서 속성 값은 계속 변할 수 있기 때문에 속성 자체가 가지고 있는 특성과 의미를 기반으로 판단해야 한다. 

[그림 9-7]의 고객 릴레이션에서 함수 종속 관계를 판단할 때도 마찬가지다.
고객 릴레이션에 현재 저장되어 있는 속성 값이 아닌 속성 자체의 특성을 고려하여 함수 종속 관계를 판단해야 한다. 고객 릴레이션에서 고객아이디는 고객을 구별해주는 기본키 속성이기 때문에 아이디가 같은 서로 다른 고객이 존재할 수 없다.
그러므로, 고객아이디가 정해지면 오직 하나의 고객 이름과 등급이 결정된다.

일반적으로 투플을 유일하게 구별하는 기본키와 후보키는 그 특성 때문에 릴레이션을 구성하는 다른 모든 속성들을 함수적으로 결정한다.
하지만 이러한 특성으로 인해 함수 종속 관계 X->Y에서 기본키나 후보키만 결정자인 X가 될 수 있는 것은 아니다. 기본키나 후보키가 아니더라도 속성 Y값을 유일하게 결정하는 속성 X는 함수 종속 관계에서 모두 결정자가 될 수 있다.
물론 릴레이션 내의 여러 투플에서 속성 X 값이 같으면 이 값과 연관된 속성 Y 값도 모두 같아야
결정자로 인정받을 수 있다. 

[그림 9-10]의 이벤트참여 릴레이션을 대상으로 좀 더 복잡한 속성들 간의 함수 종속 관계를 판단해보자. 

[그림 9-10]의 이벤트참여 릴레이션에서는 고객 아이디가 고객 이름을 유일하게 결정한다.
고객아이디가 같으면 모든 투플에서 고객이름이 반드시 같은 값을 가지기 때문이다.
그러므로 고객이름은 고객아이디에 종속되어 있어, 고객아이디가 결정자가 되고 고객이름이 종속자가 된다.

그리고 기본키인 {고객아이디, 이벤트번호} 속성 집합은 당첨여부 속성을 유일하게 결정한다.
아이디가 apple인 고객이 참여한 E001 이벤트의 당첨여부는 Y만 존재하기 때문이다.

그러므로 당첨여부는 {고객아이디, 이벤트번호}에 종속되어 있어, {고객아이디, 이벤트번호}가 결정자가 되고 당첨여부가 종속자가 된다. 물론 당첨여부뿐 아니라 고객이름도 기본키인 {고객아이디, 이벤트번호}에 종속되어 있다. 

이벤트참여 릴레이션에 존재하는 함수 종속 관계를 기호로 표현하면 다음과 같다. 

이벤트참여 릴레이션에 존재하는 함수 종속 관계에서 
{고객아이디, 이벤트번호}에 종속되어 있는 고객 이름은 {고객아이디, 이벤트번호}의 일부분인 고객아이디에도 종속되어 있다.
이런 경우, 고객 이름 속성이 {고객아이디, 이벤트번호} 속성 집합에 부분 함수 종속되었다고 한다. 

반면, 당첨여부 속성은 {고객아이디, 이벤트번호}의 일부분이 아닌 속성 집합 전체에 종속되어 있다.
이런 경우에는 당첨여부 속성이 {고객아이디, 이벤트번호} 속성 집합에 완전 함수 종속되었다고 한다.

완전 함수 종속은 릴레이션에서 속성 집합 Y가 속성 집합 X에 함수적으로 종속되어 있지만,
속성 집합 X 전체에 종속된 것이지 일부분에 종속된 것이 아님을 의미한다. 
이와 반대로 부분 함수 종속은 속성 집합 Y가 속성 집합 X의 전체가 아닌 일부분에도
함수적으로 종속됨을 의미하므로, 부분 함수 종속 관계가 성립하려면 결정자가
여러 개의 속성들로 구성되어 있어야 한다
 
일반적으로 함수 종속이라고 하면 완전 함수 종속을 의미한다.
그러나 정규화를 수행하는 과정에서 릴렐이션이 부분 함수 종속 관계를 포함하고 있는지를 확인하는 경우가 있으므로 부분 함수 종속도 의미를 정확히 이해해둘 필요가 있다. 

[그림 9-10]의 이벤트참여 릴레이션에서 고객이름은 고객아이디에 완전 함수 종속되어 있지만, {고객아이디, 이벤트번호}에는 부분 함수 종속되어 있다. 
그리고 당첨여부는 {고객아이디, 이벤트번호}에 완전 함수 종속되어 있다.

완전 함수 종속과 부분 함수 종속을 모두 포함하는 이벤트참여 릴레이션에 대한 함수 종속 다이어그램은 [그림 9-12]와 같다. 

릴레이션에 존재하는 함수 종속 관계에서는 결정자와 종속자가 같거나, 결정자가 종속자를 포함하는 것처럼 당연한 함수 종속 관계는 고려하지 않는다. 예를 들어, 이벤트참여 릴레이션에 존재하는 다음과 같은 함수 종속 관계는 당연하게 판단되는 함수 종속 관계이므로 제외한다. 
  
</details>

-----------------------

### 정규화의 개념과 정규형의 종류에는 무엇이 있습니까?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

[참고: 데이터베이스 개론 p.339]

+ 

함수 종속성을 이용하여 릴레이션을 연관성이 있는 속성들로만 구성되도록 분해해서,
이상 현상이 발생하지 않는 올바른 릴레이션으로 만들어나가는 과정을
정규화라고 한다.
정규화의 기본 목표는 관련이 없는 함수 종속성을 별개의 릴레이션으로 표현하는 것이다.

릴레이션이 정규화된 정도는 정규형으로 표현한다. 정규형은 크게 기본 정규형과 
고급 정규형으로 나뉜다.
기본 정규형에는 제1정규형, 제2정규형, 제3정규형, 보이스/코드 정규형이 있고,
고급 정규형에는 제4정규형, 제5정규형이 있다. 

각 정규형마다 만족시켜야 하는 제약조건이 존재한다.
릴레이션이 특정 정규형의 제약 조건을 만족하면 릴레이션이 해당 정규형에 속한다고 표현한다.
정규형의 차수가 높아질수록 요구되는 제약조건이 많아지고 엄격해진다.
일반적으로 차수가 높은 정규형에 속하는 릴레이션일수록
데이터 중복이 줄어 데이터 중복에 의한 이상 현상이 발생하지 않는 바람직한 릴레이션일 수 있다.
하지만 모든 릴레이션이 제5정규형에 속해야 되는 것은 아니므로,
릴레이션의 특성을 고려해서 적합한 정규형을 선택해야 한다. 

일반적으로 기본 정규형에 속하도록 릴레이션을 정규화하는 경우가 대부분이다.
따라서 기본 정규형의 제약조건은 정확히 파악해둘 필요가 있으므로,
여기서는 기본 정규형을 중심으로 정규화 과정을 알아본다.

정규형들간의 관계를 그림으로 표현하면 다음과 같다.
정규형 중 가장 바깥쪽에 위치하는 제1정규형부터 살펴보자. 
 
</details>

-----------------------

### 제1정규형이란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

[참고: 데이터베이스 개론 p.340]

+ 

 
</details>

-----------------------

### 제2정규형이란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

[참고: 데이터베이스 개론 p.340]

+ 

 
</details>

-----------------------

### 제3정규형이란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

[참고: 데이터베이스 개론 p.340]

+ 

 
</details>

-----------------------

### 보이스코드 정규형이란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

[참고: 데이터베이스 개론 p.340]

+ 

 
</details>

-----------------------

### InnoDB vs MyISAM?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

[참고: Real MySQL 1권 p,98]

+ 지금까지 MySQL 엔진의 전체적인 구조를 살펴봤다.
이번 절에서는 MySQL의 스토리지 엔진 가운데 가장 많이 사용되는 InnoDB 스토리지 엔진을 간단히 살펴보자. InnoDB는 MySQL에서 사용할 수 있는 스토리지 엔진 중 거의 유일하게 레코드 기반의 잠금을 제공하며, 그 때문에 높은 동시성 처리가 가능하고 안정적이며 성능이 뛰어나다.
InnoDB의 개략적인 구조는 그림 4.9와 같다. 

그림 4.9는 InnoDB의 아키텍처를 아주 간단히 보여주는데, 각 부분에 관한 자세한 설명은 InnoDB 스토리지 엔진의 주요 특징들과 함께 하나씩 살펴보자. 

1) 프라이머리 키에 의한 클러스터링
- InnoDB의 모든 테이블은 기본적으로 프라이머리 키를 기준으로 클러스터링되어 저장된다. 즉, 프라이머리 키 값의 순서대로 디스크에 저장된다는 뜻이며, 모든 세컨더리 인덱스는 레코드의 주소 대신 프라이머리 키의 값을 논리적인 주소로 사용한다.  프라이머리 키가 클러스터링 인덱스이기 때문에 프라이머리 키를 이용한 레인지 스캔은 상당히 빨리 처리될 수 있다.

- 결과적으로 쿼리의 실행 계획에서 프라이머리 키는 기본적으로 다른 보조 인덱스에 비해 비중이 높게 설정(쿼리의 실행 계획에서 다른 보조 인덱스보다 프라이머리 키가 선택될 확률이 높음)된다.
오라클 DBMS의 IOD(Index Organized Table)과 동일한 구조가 InnoDB에서는 일반적인 테이블의 구조가 되는 것이다. 클러스터 키에 대해서는 8.8절 '클러스터링 인덱스'에서 다시 상세히 다루겠다.

- InnoDB 스토리지 엔진과는 달리 MyISAM 스토리지 엔진에서는 클러스터링 키를 지원하지 않는다.
  그래서 MyISAM 테이블에서는 프라이머리 키와 세컨더리 인덱스는 구조적으로 아무런 차이가 없다.  프라이머리 키는 유니크 제약을 가진 세컨더리 인덱스일뿐이다. 
  그리고 MyISAM 테이블의 프라이머리 키를 포함한 모든 인덱스는 물리적인 레코드의 주소값(ROWID)을 가진다. MyISAM 테이블의 구조와 인덱스에 대해서는 4.3.3절 '데이터 파일과 프라이머리 키(인덱스) 구조'를 참고하자.

  
4.2.2 외래 키 지원

- 외래 키에 대한 지원은 InnoDB 스토리지 엔진 레벨에서 지원하는 기능으로 MyISAM이나 MEMORY 테이블에서는 사용할 수 없다. 외래 키는 데이터베이스 서버 운영의 불편함 때문에 서비스용 데이터베이스에서는 생성하지 않는 경우도 자주 있는데, 그렇다 하더라도 개발 환경의 데이터베이스에서는 좋은 가이드 역할을 할 수 있다. 

- InnoDB에서 외래 키는 부모 테이블과 자식 테이블 모두 해당 칼럼에 인덱스 생성이 필요하고, 변경 시에는 반드시 부모 테이블이나 자식 테이블에 데이터가 있는지 체크하는 작업이 필요하므로
잠금이 여러 테이블로 전파되고, 그로 인해 데드락이 발생할 때가 많으므로 개발할 때도 외래 키의 존재에 주의하는 것이 좋다

- 수동으로 데이터를 적재하거나 스키마 변경 등의 관리 작업이 실패할 수 있다. 물론 부모 테이블과 
자식 테이블의 관계를 명확히 파악해서 순서대로 작업한다면 문제 없이 실행할 수 있지만 외래 키가 복잡하게 얽힌 경우에는 그렇게 간단하지 않다. 또한 서비스에 문제가 있어서 긴급하게 뭔가 조치를 해야 하는데 이런 문제가 발생하면 더 조급해질 수도 있다. 이런 경우에는 foreign_key_checks 시스템 변수를 OFF로 설정하면 외래 키 관계에 대한 체크 작업을 일시적으로 멈출 수 있다.

- 외래 키 체크 작업을 일시적으로 멈추면 대략 레코드 적재나 삭제 등의 작업도 부가적인 체크가 필요 없기 때문에 훨씬 빠르게 처리할 수 있다.

mysql> SET foreign_key_checks = OFF;

mysql> SET foreign_key_checks= ON;

외래 키 체크를 일시적으로 해제했다고 해서 부모와 자식 테이블 간의 관계가 깨진 상태로 그대로 유지해도 된다는 것을 의미하지는 않는다.
예를 들어, 외래 키 체크를 일시적으로 중지한 상태에서 외래 키 관계를 가진 부모 테이블의 레코드를 삭제했다면 반드시 자식 테이블의 레코드도 삭제해서 일관성을 맞춰준 후 
다시 외래 키 체크 기능을 활성화해야 한다.
그리고 foreign_key_checks가 비활성화되면 외래키 관계의 부모 테이블에 대한 작업도 무시하게 된다.



 
</details>

-----------------------

### MVCC란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

[참고: Real MySQL 1권 p.100]

+ 일반적으로 레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능이며, MVCC의 가장 큰 목적은 잠금을 사용하지 않는 일관된 읽기를 제공하는데 있다.
  InnoDB는 언두 로그를 이용해 이 기능을 구현한다.
  여기서 멀티 버전이라 함은 하나의 레코드에 대해 여러 개의 버전이 동시에 관리된다는 의미다.
  이해를 위해 격리 수준(Isolation level)이 READ_COMMITTED인 MySQL 서버에서 InnoDB 스토리지 엔진을 사용하는 테이블의 데이터 변경을
  어떻게 처리하는지 그림으로 한 번 살펴보자. 

  우선 다음과 같은 테이블에 한 건의 레코드를 INSERT한 다음 UPDATE해서 발생하는 변경 작업 및 절차를 확인해보자.
  UPDATE 문장이 실행되면 커밋 실행 여부와 관계없이 InnoDB 버퍼 풀은 새로운 값인 '경기'로 업데이트 된다.
  그리고 디스크의 데이터 파일에는 체크포인트나 InnoDB의 Write 스레드에 의해 새로운 값으로 업데이트돼 있을 수도 있고 아닐 수도 있다
  (InnoDB가 ACID를 보장하기 때문에 일반적으로 InnoDB의 버퍼 풀과 데이터 파일은 동일한 상태라고 가정해도 무방하다)
  아직 COMMIT이나 ROLLBACK이 되지 않은 상태에서 다른 사용자가 다음 같은 쿼리로 작업중인 레코드를 조회하면 어디에 잇는 데이터를 조회할까?

  mysql> SELECT * FROM member WHERE m_id=12;

  이 질문의 답은 MySQL 서버의 시스템 변수(transaction_isolation)에 설정된 격리 수준(Isolation level)에 따라 다르다는 것이다.
  격리 수준이 READ_UNCOMMITTED인 경우에는 InnoDB 버퍼 풀이나 데이터 파일로부터 변경되지 않은 데이터를 읽어서 반환한다.
  즉, 데이터가 커밋됐든 아니든 변경된 상태의 데이터를 반환한다.
  그렇지 않고 READ_COMMITTED나 그 이상의 격리 수준(REPEATABLE_READ, SERIALIZABLE)인 경우에는 아직 커밋되지 않았기 때문에
  InnoDB 버퍼 풀이나 데이터 파일에 있는 내용 대신 변경되기 이전의 내용을 보관하고 있는 언두 영역의 데이터를 반환한다.

  이러한 과정을 DBMS에서는 MVCC라고 표현한다. 
  즉, 하나의 레코드(회원 번호가 12인 레코드)에 대해 2개의 버전이 유지되고, 필요에 따라 어느 데이터가 보여지는지
  여러 가지 상황에 따라 달라지는 구조다.
  여기서는 한 개의 데이터만 가지고 설명했지만, 관리해야 하는 예전 버전의 데이터는 무한히 많아질 수 있다
  (트랜잭션이 길어지면 언두에서 관리하는 예전 데이터가 삭제되지 못하고, 오랫동안 관리돼야 하며, 자연히 언두 영역이 저장되는 시스템 테이블스페이스의 
  공간이 많이 늘어나는 상황이 발생할 수도 있다)

  지금까지 UPDATE 쿼리가 실행되면 InnoDB 버퍼 풀은 즉시 새로운 데이터로 변경되고 기존 데이터는 언두영역으로 복사되는 과정까지 살펴봤는데,
  이 상태에서 COMMIT 명령을 실행하면 InnoDB는 더 이상의 변경 작업 없이 지금의 상태를 영구적인 데이터로 만들어 버린다. 
  하지만 롤백을 실행하면 InnoDB는 언두 영역에 있는 백업된 데이터를 InnoDB 버퍼 풀로 다시 복구하고, 언두 영역의 내용을 삭제해버린다.
  커밋이 된다고 언두 영역의 백업 데이터가 항상 바로 삭제되는 것은 아니다.
  이 언두 영역을 필요로 하는 트랜잭션이 더는 없을 때, 비로소 삭제된다. 
 
</details>

-----------------------

### 자동 데드락 감지란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

[참고: Real MySQL 1권 p.104]

+ InnoDB 스토리지 엔진은 내부적으로 잠금이 교착 상태에 빠지지 않았는지 체크하기 위해
  잠금 대기 목록을 그래프(Wait-for List) 형태로 관리한다.
  InnoDB 스토리지 엔진은 데드락 감지 스레드를 가지고 있어서, 데드락 감지 스레드가 주기적으로 잠금 대기 그래프를 검사해
  교착 상태에 빠진 트랜잭션을 찾아서 그 중 하나를 강제 종료한다.
  이 때, 어느 트랜잭션을 먼저 강제 종료할 것인지를 판단하는 기준은 트랜잭션의 언두 로그 양이며,
  언두 로그 레코드를 더 적게 가진 트랜잭션이 일반적으로 롤백의 대상이 된다.
  트랜잭션이 언두 레코드를 적게 가졌다는 이야기는 롤백을 해도 언두 처리를 해야 할 내용이 적다는 것이며,
  트랜잭션 강제 롤백으로 인한 MySQL 서버의 부하도 덜 유발하기 때문이다.

  참고로 InnoDB 스토리지 엔진은 상위 레이어인 MySQL 엔진에서 관리되는 테이블 잠금(LOCK TABLES 명령으로 잠긴 테이블)은
  볼 수가 없어서 데드락 감지가 불확실할 수도 있는데, innodb_table_locks 시스템 변수를 활성화하면
  InnoDB 스토리지 엔진 내부의 레코드 잠금뿐만 아니라 테이블 레벨의 잠금까지 감지할 수 있게 된다.
  특별한 이유가 없다면 innodb_table_locks 시스템 변수를 활성화하자. 

  일반적인 서비스에서는 데드락 감지 스레드가 트랜잭션의 잠금 목록을 검사해서 데드락을 찾아내는 작업은 크게 부담되지 않는다.
  하지만 동시 처리 스레드가 매우 많아지거나 각 트랜잭션이 가진 잠금의 개수가 많아지면 데드락 감지 스레드가 느려진다.
  데드락 감지 스레드는 잠금 목록을 검사해야 하기 때문에 잠금 상태가 변경되지 않도록 잠금 목록이 저장된 리스트(잠금 테이블)에
  새로운 잠금을 걸고 데드락 스레드를 찾게 된다.
  데드락 감지 스레드가 느려지면 서비스 쿼리를 처리 중인 스레드는 더는 작업을 진행하지 못하고 대기하면서 서비스에 악영향을 미치게 된다.
  이렇게 동시 처리 스레드가 매우 많은 경우 데드락 감지 스레드는 더 많은 CPU 자원을 소모할 수도 있다.

  이런 문제점을 해결하기 위해 MySQL 서버는 innodb_deadlock_detect 시스템 변수를 제공하며, innodb_deadlock_detect를 OFF 로 설정하면
  데드락 감지 스레드는 더는 작동하지 않게 된다.
  데드락 감지 스레드가 작동하지 않으면 InnoDB 스토리지 엔진 내부에서 2개 이상의 트랜잭션이 상대방이 가진 잠금을 요구하는 상황(데드락 상황)
  이 발생해도 누군가가 중재를 하지 않기 때문에 무한정 대기하게 될 것이다.

  하지만 innodb_lcok_wait_timeout 시스템 변수를 활성화하면 이런 데드락 상황에서 일정 시간이 지나면 자동으로 요청이 실패하고,
  에러 메시지를 반환하게 된다. innodb_lock_wait_timeout은 초 단위로 설정할 수 있으며, 잠금을 설정한 시간 동안 획득하지 못하면 쿼리는 실패하고
  에러를 반환한다. 데드락 감지 스레드가 부담되어 innodb_deadlock_detect를 OFF로 설정해서 비활성화하는 경우라면 innodb_lock_wait_timeout을
  기본값인 50초보다 훨씬 낮은 시간으로 변경해서 사용할 것을 권장한다. 
  
 
</details>

-----------------------


### 트랜잭션이란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

[참고: Real MySQL 1권 p.155]

+ 

이번 장에서는 MySQL의 동시성에 영향을 미치는 잠금(Lock)과  트랜잭션, 트랜잭션의 격리 수준(Isolation level)을 살펴보겠다.

트랜잭션은 작업의 완전성을 보장해주는 것이다. 즉, 논리적인 작업 셋을 모두 완벽하게 처리하거나, 처리하지 못할 경우에는 원 상태로 복구해서 작업의 일부만 적용되는 현상(Partial Update)이 발생하지 않게 만들어주는 기능이다.

잠금(Lock)과 트랜잭션은 서로 비슷한 개념 같지만 사실 잠금은 동시성을 제어하기 위한 기능이고 ,트랜잭션은 데이터의 정합성을 보장하기 위한 기능이다. 하나의 회원 정보 레코드를 여러 커넥션에서 동시에 변경하려고 하는데 잠금이 없다면, 하나의 데이터를 여러 커넥션에서 동시에 변경할 수 있게 된다. 결과적으로 해당 레코드의 값은 예측할 수 없는 상태가 된다.
잠금은 여러 커넥션에서 동시에 동일한 자원(레코드나 테이블)을 요청할 경우 순서대로 한 시점에는 하나의 커넥션만 변경할 수 있게 해주는 역할을 한다. 
격리 수준이라는 것은 하나의 트랜잭션 내에서 또는 여러 트랜잭션 간의 작업 내용을 어떻게 공유하고 차단할 것인지를 결정하는 레벨을 의미한다. 

많은 사용자들이 데이터베이스 서버에서 트랜잭션이 개발자에게 얼마나 큰 혜택을 제공하는지를 자주 잊어버리는 것 같다. 지금은 많이 달라졌지만 여전히 MySQL 서버에서는 MyISAM이나 MEMORY 스토리지 엔진이 더 빠르다고 생각하고, InnoDB 스토리지 엔진은 사용하기 복잡하고 번거롭다고 생각하곤 한다. 하지만 사실은 MyISAM이나 MEMORY 같이 트랜잭션을 지원하지 않는 스토리지 엔진의 테이블이 더 많은 고민거리를 만들어 낸다. 

이번 절에서는 트랜잭션을 지원하지 않는 MyISAM과 트랜잭션을 지원하는 InnoDB의 처리 방식 차이를 잠깐 살펴보고자 한다. 그리고  트랜잭션을 사용할 경우 주의할 사항도 함께 살펴보겠다.

1) MySQL에서의 트랜잭션
- 트랜잭션은 꼭 여러 개의 변경 작업을 수행하는 쿼리가 조합됐을 때만 의미 있는 개념은 아니다.
   트랜잭션은 하나의 논리적인 작업 셋에 하나의 쿼리가 있든 두 개 이상의 쿼리가 있든 
   관계없이 논리적인 작업 셋 자체가 100% 적용되거나(COMMIT을 실행했을 때)
   아무것도 적용되지 않아야(ROLLBACK 또는 트랜잭션을 ROLLBACK 시키는 오류가 발생했을 때)
   함을 보장해주는 것이다. 

간단한 예제로 트랜잭션 관점에서 InnoDB 테이블과 MyISAM 테이블의 차이를 살펴보자. 

mysql> CREATE TABLE tab_myisam (fdpk INT NOT NULL, PRIMARY KEY (fdpk)) ENGINE=MyISAM;
mysql> INSERT INTO tab_myisam (fdpk) VALUES (3);

mysql> CREATE TABLE tab_innodb (fdpk INT NOT NULL, PRIMARY KEY (fdpk)) ENGINE = INNODB;
mysql> INSERT INTO tab_innodb (fdpk) VALUES (3);

위와 같이 테스트용 테이블에 각각 레코드를 1건씩 저장한 후 AUTO-COMMIT 모드에서 다음 쿼리 문장을 InnoDB 테이블과 MyISAM 테이블에서 각각 실행해보자.

mysql> SET autocommit=ON;

mysql> INSERT INTO tab_myisam (fdpk) VALUES (1), (2), (3);
mysql> INSERT INTO tab_innodb (fdpk) VALUES (1), (2), (3);

두 개의 스토리지 엔진에서 결과가 어떻게 다를까?
위 쿼리 문장의 테스트 결과는 다음과 같다. 

mysql> INSERT INTO tab_myisam (fdpk) VALUES (1), (2), (3);
ERROR 1062 (23000): Duplicate entry '3' for key 'PRIMARY'

mysql> INSERT INTO tab_innodb (fdpk) VALUES (1), (2), (3);
ERROR 1062 (23000): Duplicate entry '3' for key 'PRIMARY'

mysql> SELECT * FROM tab_myisam;
fdpk
1
2
3

mysql> SELECT * FROM tab_innodb;
fdpk
3

두 INSERT 문장 모두 프라이머리 키 중복 오류로 쿼리가 실패했다.
그런데 두 테이블의 레코드를 조회해보면 MyISAM 테이블에는 오류가 발생했음에도
'1'과 '2'는 INSERT된 상태로 남아 있는 것을 확인할 수 있다.

즉, MyISAM 테이블에 INSERT 문장이 실행되면서 차례대로 '1'과 '2'를 저장하고, 그 다음 '3'을 저장하려고 하는 순간, 중복 키 오류(이미 '3'이 있기 때문)가 발생한 것이다.
하지만 MyISAM 테이블에서 실행되는 쿼리는 이미 INSERT된 '1'과 '2'를 그대로 두고
쿼리 실행을 종료해 버린다. 

MEMORY 스토리지 엔진을 사용하는 테이블도 MyISAM 테이블과 동일하게 작동한다. 
하지만 InnoDB는 쿼리 중 일부라도 오류가 발생하면 전체를 원 상태로 만든다는 트랜잭션의
원칙대로 INSERT 문장을 실행하기 전 상태로 그대로 복구했다.
MyISAM 테이블에서 발생하는 이러한 현상을 부분 업데이트(Partial Update)라고 표현하며,
이러한 부분 업데이트 현상은 테이블 데이터의 정합성을 맞추는데 상당히 어려운 문제를
만들어 낸다. 

어떤 사용자는 (특히 트랜잭션이 선택 사항인 MySQL의 경우) 트랜잭션을 상당히 골치 아픈 기능쯤으로 생각하지만 트랜잭션이란 그만큼 애플리케이션 개발에서 고민해야 할 문제를 줄여주는 아주 필수적인 DBMS의 기능이라는 점을 기억해야 한다. 
 부분 업데이트 현상이 발생하면 실패한 쿼리로 인해 남은 레코드를 다시 삭제하는 재처리 작업이 필요할 수 있다. 실행하는 쿼리가 하나뿐이라면 재처리 작업은 간단할 것이다.
하지만 2개 이상의 쿼리가 실행되는 경우라면 실패에 대한 재처리 작업은 다음 예제와 같이 상당한 고민거리가 될 것이다. 

위 애플리케이션 코드가 장난처럼 작성한 코드 같지만 트랜잭션이 지원되지 않는 MyISAM에 레코드를 INSERT할 때 위와 같이 하지 않으면 방법이 없다. 코드를 이렇게 작성하지 않았다면 부분 업데이트의 결과를 쓰레기 데이터가 테이블에 남아 있을 가능성이 있다. 하지만 위의 코드를 트랜잭션이 지원되는 InnoDB 테이블에서 처리한다고 가정하면 다음과 같은 간단한 코드로 완벽한 구현이 가능하다. 얼마나 깔끔한 코드로 바뀌었는가! 비즈니스 로직 처리로 이미 IF... ELSE... 로 가득한 프로그램 코드에 이런 데이터 클렌징 코드까지 넣어야 한다는 것은 정말 암담한 일일 것이다. 

 
</details>

-----------------------

### 트랜잭션 격리 수준이란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

[참고: 데이터베이스 개론 p.340]

+ 

 
</details>

-----------------------

### 트랜잭션 전파 방식이란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

[참고: 데이터베이스 개론 p.340]

+ 

 
</details>

-----------------------








