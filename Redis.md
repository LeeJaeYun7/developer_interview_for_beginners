# Redis
<br>

-----------------------

### Redis vs Memcached?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
 
   1. Redis
  - Redis는 캐시 솔루션 + 저장소입니다. <br>
  - Redis는 Key-value, List, Hash, Set, Sorted Set과 같은 다양한 자료구조를 지원합니다. <br>
  - Redis는 싱글 스레드로 동작합니다. <br>
  - Redis는 트랜잭션, 스냅샷, Replication, Pub/sub, Lua Scripting과 같은 기능을 지원합니다. <br>
   
   2. Memcached 
  - Memcached는 캐시 솔루션입니다.
  - Memcached는 Key-value 자료구조를 지원합니다.
  - Memcached는 멀티 스레드로 동작합니다. 
</details>

-----------------------

### Redis에서 Client-side caching이란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
 [참고: https://redis.io/docs/manual/client-side-caching/]

- 클라이언트 측 캐싱은 고성능 서비스를 만드는데 사용되는 기술입니다
  데이터베이스 노드와 비교하여 일반적으로 별개의 컴퓨터인 서버인 애플리케이션 서버에서
  사용 가능한 메모리를 활용하여 데이터베이스 정보의 일부 하위 집합을 애플리케이션 측에 직접 저장합니다.

  일반적으로 데이터가 필요한 경우 애플리케이션 서버는 다음 다이어그램과 같이 이러한 정보에 대해 데이터베이스에 요청합니다.
  +-------------+                                +----------+
|             | ------- GET user:1234 -------> |          |
| Application |                                | Database |
|             | <---- username = Alice ------- |          |
+-------------+                                +----------+
   클라이언트 측 캐싱이 사용되면 애플리케이션은 인기 있는 쿼리의 응답을 애플리케이션 메모리 내부에
   직접 저장하므로 나중에 데이터베이스에 다시 접속하지 않고도 이러한 응답을 재사용할 수 있습니다.
   +-------------+                                +----------+
|             |                                |          |
| Application |       ( No chat needed )       | Database |
|             |                                |          |
+-------------+                                +----------+
| Local cache |
|             |
| user:1234 = |
| username    |
| Alice       |
+-------------+
  - 로컬 캐시에 사용되는 애플리케이션 메모리는 그다지 크지 않을 수 있지만,
    로컬 컴퓨터 메모리에 액세스하는데 필요한 시간은 데이터베이스와 같은
    네트워크 서비스에 액세스하는 것과 비교할 때 훨씬 적습니다.
    동일한 작은 비율의 데이터가 자주 액세스되기 때문에 이 패턴은 애플리케이션이 데이터를
    가져오는 대기 시간과 동시에 데이터베이스 측의 로드를 크게 줄일 수 있습니다.

  - 또한, 항목이 매우 드물게 변경되는 많은 데이터 세트가 있습니다.
    예를 들어, 소셜 네트워크의 대부분의 사용자 게시물은 변경할 수 없거나
    사용자가 거의 편집하지 않습니다 .
    여기에 일반적으로 소수의 게시물이 매우 인기가 있다는 사실을 추가하면
    소수의 사용자가 팔로워가 많거나 최근 게시물의 가시성이 훨씬 높기 때문에
    이러한 패턴이 나타날 수 있는 이유는 분명합니다. 

  - 일반적으로 클라이언트 쪽 캐싱의 두 가지 주요 이점은 다음과 같습니다.
  (1) 매우 짧은 대기 시간으로 데이터를 사용할 수 있습니다
  (2) 데이터베이스 시스템은 더 적은 쿼리를 수신하므로, 더 적은 수의 노드로 동일한 데이터 세트를 제공할 수 있습니다. 
</details>

-----------------------

### Redis Client-side cacheing의 문제점은 무엇입니까?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: https://redis.io/docs/manual/client-side-caching/] 
+ 컴퓨터 과학에는 두 가지 어려운 문제가 있습니다
  위 패턴의 문제점은 사용자에게 오래된 데이터가 표시되지 않도록 애플리케이션이 보유하고 있는 정보를
  무효화하는 방법입니다.
  예를 들어, 위의 애플리케이션이 user:1234에 대한 정보를 로컬로 캐시한 후 Alice는 자신의 사용자 이름을
  Flora로 업데이트할 수 있습니다.
  그러나 응용 프로그램은 사용자:1234의 이전 사용자 이름을 계속 제공할 수 있습니다.
  
  때때로 우리가 모델링하는 정확한 애플리케이션에 따라 이것은 큰 문제가 아니므로,
  클라이언트는 캐시된 정보에 대해 고정된 최대 "수명"을 사용합니다.
  일정 시간이 지나면 해당 정보는 더 이상 유효하지 않은 것으로 간주됩니다. 

  더 복잡한 패턴은 Redis를 사용할 때 Pub/Sub 시스템을 활용하여 수신 클라이언트에 무효화 메시지를 보냅니다. 
  이것은 작동하도록 만들 수 있지만 사용되는 대역폭의 관점에서 볼 때, 까다롭고 비용이 많이 듭니다. 
  왜냐하면 특정 클라이언트가 무효화된 데이터의 복사본을 가지고 있지 않은 경우에도
  이러한 패턴은 종종 애플리케이션의 모든 클라이언트에 무효화 메시지를 보내는 것과 관련되기 때문입니다. 
  또한, 데이터를 변경하는 모든 애플리케이션 쿼리는 PUBLISH 명령을 사용해야 하므로
  데이터베이스에서 이 명령을 처리하는데 더 많은 CPU 시간이 소요됩니다. 

  사용되는 스키마에 관계없이 간단한 사실이 있습니다.
  매우 큰 응용 프로그램은 빠른 저장 또는 빠른 캐시 서버를 갖는 다음 논리적 단계이기 때문에
  어떤 형태의 클라이언트 측 캐싱을 구현합니다.
  이러한 이유로 Redis6는 클라이언트 측 캐싱에 대한 직접적인 지원을 구현하여
  이 패턴을 훨씬 더 간단하게 구현하고, 액세스 가능하며 안정적이고 효율적으로 만듭니다. 
</details>

-----------------------


### Redis Client-side cacheing은 어떻게 구현됩니까?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: https://redis.io/docs/manual/client-side-caching/] 
+ 
</details>

-----------------------


### Redis Single thread는 어떤 식으로 동작하는가?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+  
</details>

-----------------------


### Redis Pub-sub은 어떤 식으로 동작하는가?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+ Pub-sub 패턴이란, Publisher들이 특정한 subscriber를 고려하지 않고 메시지를 생성한 후, <br>
  Publish된 메시지들이 channel로 분류된 후, <br>
  Subscribers는 자신이 관심 있는 channel에 있는 메시지만 받아보는 방식을 의미합니다.<br>
   
  이러한 Publisher와 Subscriber의 디커플링으로 인해 갖게 되는 Pub-sub 패턴의 장점은<br>
  높은 확장성과 다이내믹한 네트워크 토폴로지를 가능하게 한다는 점입니다.  
</details>

-----------------------

