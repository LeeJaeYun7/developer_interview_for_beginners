# Redis
<br>

### Redis vs Memcached?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
 
   1. Redis
  - Redis는 캐시 솔루션 + 저장소입니다. <br>
  - Redis는 Key-value, List, Hash, Set, Sorted Set과 같은 다양한 자료구조를 지원합니다. <br>
  - Redis는 싱글 스레드로 동작합니다. <br>
  - Redis는 트랜잭션, 스냅샷, Replication, Pub/sub, Lua Scripting과 같은 기능을 지원합니다. <br>
   
   2. Memcached 
  - Memcached는 캐시 솔루션입니다.
  - Memcached는 Key-value 자료구조를 지원합니다.
  - Memcached는 멀티 스레드로 동작합니다. 
</details>

-----------------------

### Redis에서 Client-side caching이란?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
 [참고: https://redis.io/docs/manual/client-side-caching/]

- 클라이언트 측 캐싱은 고성능 서비스를 만드는데 사용되는 기술입니다
  데이터베이스 노드와 비교하여 일반적으로 별개의 컴퓨터인 서버인 애플리케이션 서버에서
  사용 가능한 메모리를 활용하여 데이터베이스 정보의 일부 하위 집합을 애플리케이션 측에 직접 저장합니다.

  일반적으로 데이터가 필요한 경우 애플리케이션 서버는 다음 다이어그램과 같이 이러한 정보에 대해 데이터베이스에 요청합니다.
  +-------------+                                +----------+
|             | ------- GET user:1234 -------> |          |
| Application |                                | Database |
|             | <---- username = Alice ------- |          |
+-------------+                                +----------+
   클라이언트 측 캐싱이 사용되면 애플리케이션은 인기 있는 쿼리의 응답을 애플리케이션 메모리 내부에
   직접 저장하므로 나중에 데이터베이스에 다시 접속하지 않고도 이러한 응답을 재사용할 수 있습니다.
   +-------------+                                +----------+
|             |                                |          |
| Application |       ( No chat needed )       | Database |
|             |                                |          |
+-------------+                                +----------+
| Local cache |
|             |
| user:1234 = |
| username    |
| Alice       |
+-------------+
  - 로컬 캐시에 사용되는 애플리케이션 메모리는 그다지 크지 않을 수 있지만,
    로컬 컴퓨터 메모리에 액세스하는데 필요한 시간은 데이터베이스와 같은
    네트워크 서비스에 액세스하는 것과 비교할 때 훨씬 적습니다.
    동일한 작은 비율의 데이터가 자주 액세스되기 때문에 이 패턴은 애플리케이션이 데이터를
    가져오는 대기 시간과 동시에 데이터베이스 측의 로드를 크게 줄일 수 있습니다.

  - 또한, 항목이 매우 드물게 변경되는 많은 데이터 세트가 있습니다.
    예를 들어, 소셜 네트워크의 대부분의 사용자 게시물은 변경할 수 없거나
    사용자가 거의 편집하지 않습니다 .
    여기에 일반적으로 소수의 게시물이 매우 인기가 있다는 사실을 추가하면
    소수의 사용자가 팔로워가 많거나 최근 게시물의 가시성이 훨씬 높기 때문에
    이러한 패턴이 나타날 수 있는 이유는 분명합니다. 

  - 일반적으로 클라이언트 쪽 캐싱의 두 가지 주요 이점은 다음과 같습니다.
  (1) 매우 짧은 대기 시간으로 데이터를 사용할 수 있습니다
  (2) 데이터베이스 시스템은 더 적은 쿼리를 수신하므로, 더 적은 수의 노드로 동일한 데이터 세트를 제공할 수 있습니다. 
</details>

-----------------------

### Redis Client-side cacheing의 문제점은 무엇입니까?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: https://redis.io/docs/manual/client-side-caching/] 
+ 컴퓨터 과학에는 두 가지 어려운 문제가 있습니다
  위 패턴의 문제점은 사용자에게 오래된 데이터가 표시되지 않도록 애플리케이션이 보유하고 있는 정보를
  무효화하는 방법입니다.
  예를 들어, 위의 애플리케이션이 user:1234에 대한 정보를 로컬로 캐시한 후 Alice는 자신의 사용자 이름을
  Flora로 업데이트할 수 있습니다.
  그러나 응용 프로그램은 사용자:1234의 이전 사용자 이름을 계속 제공할 수 있습니다.
  
  때때로 우리가 모델링하는 정확한 애플리케이션에 따라 이것은 큰 문제가 아니므로,
  클라이언트는 캐시된 정보에 대해 고정된 최대 "수명"을 사용합니다.
  일정 시간이 지나면 해당 정보는 더 이상 유효하지 않은 것으로 간주됩니다. 

  더 복잡한 패턴은 Redis를 사용할 때 Pub/Sub 시스템을 활용하여 수신 클라이언트에 무효화 메시지를 보냅니다. 
  이것은 작동하도록 만들 수 있지만 사용되는 대역폭의 관점에서 볼 때, 까다롭고 비용이 많이 듭니다. 
  왜냐하면 특정 클라이언트가 무효화된 데이터의 복사본을 가지고 있지 않은 경우에도
  이러한 패턴은 종종 애플리케이션의 모든 클라이언트에 무효화 메시지를 보내는 것과 관련되기 때문입니다. 
  또한, 데이터를 변경하는 모든 애플리케이션 쿼리는 PUBLISH 명령을 사용해야 하므로
  데이터베이스에서 이 명령을 처리하는데 더 많은 CPU 시간이 소요됩니다. 

  사용되는 스키마에 관계없이 간단한 사실이 있습니다.
  매우 큰 응용 프로그램은 빠른 저장 또는 빠른 캐시 서버를 갖는 다음 논리적 단계이기 때문에
  어떤 형태의 클라이언트 측 캐싱을 구현합니다.
  이러한 이유로 Redis6는 클라이언트 측 캐싱에 대한 직접적인 지원을 구현하여
  이 패턴을 훨씬 더 간단하게 구현하고, 액세스 가능하며 안정적이고 효율적으로 만듭니다. 
</details>

-----------------------


### Redis Client-side caching은 어떻게 구현됩니까?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
[참고: https://redis.io/docs/manual/client-side-caching/] 
+ Redis 클라이언트 측 캐싱 지원을 추적이라고 하며, 두 가지 모드가 있습니다.
  기본 모드에서는 서버는 주어진 클라이언트가 액세스한 키를 기억하고,
  동일한 키가 수정되면 무효화 메시지를 보냅니다. 
  이는 서버 측에서 메모리 비용이 들지만, 클라이언트가 메모리에 가질 수 있는 키 집합에 대해서만
  무효화 메시지를 보냅니다.
  브로드캐스팅 모드에서 서버는 주어진 클라이언트가 액세스한 키를 기억하려고 하지 않으므로
  이 모드는 서버 측에서 메모리 비용이 전혀 들지 않습니다. 
  대신 클라이언트는 object: 또는 user:와 같은 키 접두사를 구독하고 구독한 접두사와 일치하는 키가 
  터치될때마다 알림 메시지를 받습니다. 

  요약하자면, 지금은 브로드캐스팅 모드에 대해 잠시 잊고 첫 번째 모드에 집중하겠습니다. 
  브로드캐스팅에 대해서는 나중에 자세히 설명하겠습니다. 
  클라이언트는 원하는 경우 추적을 활성화할 수 있습니다. 
  추적이 활성화되지 않은 상태에서 연결이 시작됩니다.

  추적이 활성화되면 서버는 연결 수명 동안 각 클라이언트가 요청한 키를 기억합니다. 
  (해당 키에 대한 읽기 명령 전송)
  키가 일부 클라이언트에 의해 수정되거나 연관도니 만료 시간이 있기 때문에
  축출되거나 maxmemory 정책으로 인해 축출되면 키가 캐시되었을 수 있는 추적이 
  활성화된 모든 클라이언트에게 무효화 메시지가 통지됩니다. 
  클라이언트가 무효화 메시지를 받으면 부실 데이터 제공을 방지하기 위해 해당 키를 제거해야 합니다. 

  다음은 프로토콜의 예입니다. 
  클라이언트 1 -> 서버: CLIENT TRACKING ON 
  클라이언트 1 -> 서버: GET foo(서버는 클라이언트 1이 캐시된 키 "foo"를 가질 수 있음을 기억합니다)
  (클라이언트 1은 로컬 메모리 내의 "foo" 값을 기억할 수 있습니다.)
  클라이언트 2 -> 서버 SET foo SomeOtherValue
  서버 -> 클라이언트 1: "foo" 무효
</details>

-----------------------

### Redis Pipe lining이란 무엇입니?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />
 [참고: https://redis.io/docs/manual/pipelining/]
+ Redis 파이프라이닝은 개별 명령에 대한 응답을 기다리지 않고 한 번에 여러 명령을 내림으로써 성능을 향상시키는 
  기술입니다. 파이프라이닝은 대부분의 Redis 클라이언트에서 지원됩니다.
  이 문서는 파이프라이닝이 해결하도록 설계된 문제와 Redis에서 파이프라이닝이 작동하는 방식을 설명합니다. 

  Redis는 클라이언트-서버 모델과 요청/응답 프로토콜을 사용하는 TCP 서버입니다. 
  이는 일반적으로 다음 단계를 통해 요청이 완료됨을 의미합니다. 
  클라이언트는 서버에 쿼리를 보내고 일반적으로 차단 방식으로 소켓에서 서버 응답을 읽습니다.
  서버는 명령을 처리하고 응답을 다시 클라이언트로 보냅니다.
  예를 들어, 네 개의 명령 시퀀스는 다음과 같습니다. 

  클라이언트: INCR  
</details>



### Redis Single thread는 어떤 식으로 동작하는가?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+  
</details>

-----------------------


### Redis Pub-sub은 어떤 식으로 동작하는가?

<details>
   <summary> 답안 보기 (👈 Click)</summary>
<br />

+ Pub-sub 패턴이란, Publisher들이 특정한 subscriber를 고려하지 않고 메시지를 생성한 후, <br>
  Publish된 메시지들이 channel로 분류된 후, <br>
  Subscribers는 자신이 관심 있는 channel에 있는 메시지만 받아보는 방식을 의미합니다.<br>
   
  이러한 Publisher와 Subscriber의 디커플링으로 인해 갖게 되는 Pub-sub 패턴의 장점은<br>
  높은 확장성과 다이내믹한 네트워크 토폴로지를 가능하게 한다는 점입니다.  
</details>

-----------------------

